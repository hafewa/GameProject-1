using UnityEngine;
using System.Collections;
using System;
using DG.Tweening; 
[AddComponentMenu("QK/YQ2/CameraCtrl")]
[RequireComponent(typeof(TransformMixer))]
public class YQ2CameraCtrl : MonoBehaviour
{
    public static YQ2CameraCtrl Single = null;
    void Awake()
    {
        m_TransformMixer = GetComponent<TransformMixer>();
        m_OffsetTransform = gameObject.AddComponent<PositionTransform>();//增加一个位置合成器，用于描述相机偏移量
        Single = this;

        m_TransformMixer.MainPositionTransform.OnValueChanged += OnCameraPositionTransform;
        m_OffsetTransform.OnValueChanged += OnCameraPositionTransform;
    }

    void OnCameraPositionTransform(PositionTransform self)
    {
        if (OnPoschanged != null)
        {
            m_TransformMixer.ManualUpdate();
            OnPoschanged(transform.position);
        }
    }

    /// <summary>
    /// 立即合成变换
    /// </summary>
   public void MixerTransform()
    {
        m_TransformMixer.ManualUpdate();
    }


    void Start()
    {
        EasyTouch.On_TouchDown += OnTouchDownHandler;
        EasyTouch.On_TouchUp += OnTouchUpHandler;


        EasyTouch.On_PinchIn += OnPinchIn;
        //EasyTouch.On_PinchOut += OnPinchOut;
        //EasyTouch.On_TouchUp2Fingers += OnTouchUp2Fingers;

        //EasyTouch.On_LongTap += OnLongTap; 
        m_ScrollObject = GetComponent<BoxScrollObject>();
    }

    /// <summary>
    /// 相机追踪的物体位置改变
    /// </summary>
    public void OnTrackPosChanged(Vector3 pos3d)
    {
        if ( m_WorkMode != WorkMode.Obj  ) 
            return;
        //m_HasTrackPos3d = true;//标记已经获得了追踪位置
      
        if (m_TrackPos3d != pos3d)//产生了移动
        {
            CDLockd = false;
            XOffsetTo(GetXOffset(), Ease.Linear, true, SData_MapData.Single.Camera_ZhuanshenTime);
        }

        m_TrackPos3d = pos3d; //更新追踪目标位置


        //计算相机的目标位置和目标旋转角度，并根据情况决定是用何种方式插值移动 

        var x = m_TrackPos3d.x; //+ (m_ActorDirX > 0 ? m_XOffset : -m_XOffset)
        var z = m_TrackPos3d.z  ;
        Vector3 oldPos = m_ScrollObject.ScrollViewPosition; 
        var newPos = new Vector3(x, m_Height, z); 

        var distance = Vector3.Distance(oldPos, newPos);
        if (distance > QKMath.PRECISION)
        {
           
            var gd = DiamondGridMap.wxs * SData_MapData.Single.TerrainCellBianchang;
            distance /= gd;

            float time =  m_FocusObjChanged ? distance * distance / 30000f : 0f;//距离越大时间加成越大
            if (newPos.x < -99999)
                time = 0;//非法距离，瞬间移动
            else if (m_FocusObjChanged&&time < 0.1f) time = 0.1f;


            MoveTo(
                newPos,
                m_FocusObjChanged ? Ease.OutQuart : Ease.Linear,
                m_FocusObjChanged?false:true,
                time
                );
        }

        m_FocusObjChanged = false;
    }

    //设定相机缩放
    public void SetScale(float scale)
    {
        //if (m_WorkMode == WorkMode.Obj && !m_HasTrackPos3d) return;//锁视角尚未获得追踪位置

        m_Scale = scale;

       
        ScaleLerp();

         
        float   x, z;

        if (m_WorkMode == WorkMode.Free)
        {
            Vector3 currPos = m_ScrollObject.ScrollViewPosition;
            //m_CurrXPos = currPos.x - oldXOffset + (m_XOffset - oldXOffset);

            //x = currPos.x;// + (m_XOffset - oldXOffset);
            //x = m_CurrXPos;
            x = currPos.x;
            z = currPos.z; 
            //m_CurrXOffset = m_XOffset;
        }
        else //锁定目标模式
        {
            x = m_TrackPos3d.x ;
            z = m_TrackPos3d.z ;
        }
         
        XOffsetTo(GetXOffset(), Ease.Linear,true,0f);
        ZOffsetTo(m_ZOffset, Ease.Linear, true, 0f);
        MoveTo(new Vector3(x, m_Height, z), Ease.Linear,true,0f);
        RotXTo(m_Rotation, Ease.Linear, 0f);
    }

    //设定相机y轴旋转系数 0-1
    public void SetYRot(float xs)
    { 
        m_YRotScale = xs;
        //Debug.Log("xs:"+xs.ToString());
        float yRot = Mathf.Lerp(
            SData_MapData.Single.CameraY_XuanzhuanMin,
            SData_MapData.Single.CameraY_XuanzhuanMax,
            m_YRotScale
            );


        Vector3 tmpEuler = m_TransformMixer.MainRotationTransform.Value.eulerAngles;
        tmpEuler.y = yRot;
        //Debug.Log("xs:" + xs.ToString() + "   " + yRot);
        m_TransformMixer.MainRotationTransform.Value = Quaternion.Euler(tmpEuler);
        ApplyOffset();//y旋转会影响偏移量
    }


    void ScaleLerp()
    {
        m_Height = Mathf.Lerp(SData_MapData.Single.Camera_YOffsetMax, SData_MapData.Single.Camera_YOffsetMin, m_Scale);
        m_Rotation = Mathf.Lerp(SData_MapData.Single.Camera_RotationMax, SData_MapData.Single.Camera_RotationMin, m_Scale);
        m_ZOffset = Mathf.Lerp(SData_MapData.Single.Camera_ZOffsetMax, SData_MapData.Single.Camera_ZOffsetMin, m_Scale);
        m_XOffset = Mathf.Lerp(SData_MapData.Single.Camera_XOffsetMax, SData_MapData.Single.Camera_XOffsetMin, m_Scale);
    }

    /// <summary>
    /// 相机注视某点(不改变旋转角度和高度)
    /// </summary>
    /*public void LookAt(float worldx, float worldz)
    {
        var oldPos =m_ScrollObject.ScrollViewPosition;
        float height = oldPos.y;
        Vector3 dir = -(m_TransformMixer.MainRotationTransform.Value * Vector3.forward);
        dir.Normalize();//归一化
        Plane pl = new Plane(Vector3.down, new Vector3(worldx, height, 0));
        Ray ray = new Ray(new Vector3(worldx, 0, worldz), dir);
        float enter; pl.Raycast(ray, out enter);
        var newPos = ray.GetPoint(enter);

        //距离比较远的时候用减速运动提升效果，较近的时候用匀速运动防止抖动
        MoveTo(newPos, Vector3.Distance(oldPos, newPos) > (1*DiamondGridMap.wxs * SData_MapData.Single.TerrainCellBianchang) ? Ease.OutQuart : Ease.Linear,float, 0.2f);
    }*/



    /// <summary>
    /// 切换跟随目标，同时进入目标跟随模式
    /// </summary>
    public void SwapTrackObject(
        Vector3 trackPos3d,float actorDirX,
        bool isZhuanshen
        ) 
    {
        //m_TrackPos3d = trackPos3d;
        m_ActorDirX = actorDirX;
        //m_HasTrackPos3d = false;//当前尚未取得追踪物的3D位置
        //m_FocusHeroDataID = dataID;
        //m_FocusIsAttack = isAttack;
        m_WorkMode = WorkMode.Obj; 

        //ScaleLerp();

        //停止位置补间
        StopPosXTweener();
        StopPosYTweener();
        StopPosZTweener();

        //目标物改变标志
        m_FocusObjChanged = true;

        
        if (isZhuanshen)//中途转身的处理
        {
            CDLockd = true;
            //CD = SData_MapData.Single.Camera_ZhuanshenCD;

            //平滑的移动x偏移
            XOffsetTo(GetXOffset(), Ease.Linear, false,
                SData_MapData.Single.Camera_ZhuanshenTime
            );
        } else 
        {
            CDLockd = false;  

            //当前x偏移量直接变化到最终值
            XOffsetTo(
                (m_ActorDirX > 0 ? m_XOffset : -m_XOffset)
                , Ease.Linear, false, 0);
        }

        //立即补间位置
        OnTrackPosChanged(trackPos3d);
    }


    float GetXOffset()
    {
        if (CDLockd  ) return 0;
        return m_ActorDirX > 0 ? m_XOffset : -m_XOffset;
    }
    bool CDLockd = false;
    //float CD;

    //二指拉近
    void OnPinchIn(Gesture gesture)
    {

        if (!m_EnabledScale) return;

        float scale = m_Scale - gesture.deltaPinch * InOutScale;
        if (scale < 0) scale = 0;
        SetScale(scale);
    }


    //二指拉远
    void OnPinchOut(Gesture gesture)
    {
        if (!m_EnabledScale) return;

        float scale = m_Scale + gesture.deltaPinch * InOutScale;
        if (scale > 1) scale = 1;
        SetScale(scale);
    }

    //二指缩放结束保存
    void OnTouchUp2Fingers(Gesture gesture)
    {
        if (istuiguan)
            CPlayerPrefs.Single.SetUserDate("CameraScale", m_Scale.ToString("f5"));
    }

    //拖拽
    void OnTouchDownHandler(Gesture gesture)
    {
        if (!m_EnabledTouch || gesture.touchCount > 1) return;

        InterruptObjMode();

        StopPosXTweener();
        StopPosZTweener();

        const float movescale = TouchScale;

     

        var rotY = m_TransformMixer.MainRotationTransform.Value.eulerAngles.y;

        var rDir = Quaternion.Euler(0, rotY, 0) * Vector3.left;
        var fDir = Quaternion.Euler(0, rotY, 0) * Vector3.back;

        rDir.Normalize();
        fDir.Normalize();

        var add = rDir*gesture.deltaPosition.x * movescale +
        fDir*gesture.deltaPosition.y * movescale;

        //localPos.x -= gesture.deltaPosition.x * movescale;
        //localPos.z -= gesture.deltaPosition.y * movescale;
        Vector3 localPos = m_ScrollObject.ScrollLogicPosition;
        localPos += add;
        m_ScrollObject.MoveTo(localPos);  


        //抛出用户自行移动相机事件
        if (OnUserTouch != null) OnUserTouch();
    }

     
    public event Action OnUserTouch;
    public event Action<Vector3> OnPoschanged;

    /// <summary>
    /// 跳转到世界位置，无惯性
    /// </summary>
    public void JumpToWorldPos(float x,float z)
    {
        if (!m_EnabledTouch) return;//已禁用

        InterruptObjMode();
        StopAllTween();
        Vector3 localPos = m_ScrollObject.ScrollLogicPosition;
        localPos.x = x;
        localPos.z = z;
        m_ScrollObject.JumpTo(localPos);
    }


    void OnLongTap(Gesture gesture) {
        if (!m_EnabledRot || gesture.touchCount > 1) return;

        var v = gesture.deltaTime * YRotScale;

        var ps = gesture.position;

        if(ps.x<Screen.width/2)//长按屏幕左侧
            m_YRotScale += v;
        else//长按屏幕右侧
            m_YRotScale -= v;

        m_YRotScale = Mathf.Clamp(m_YRotScale, 0, 1);

        this.SetYRot(m_YRotScale);

        if (OnUserYRot!= null) OnUserYRot();
    }
     
    public event Action OnInterruptObjMode;//目标相机模式被打断
     
    public event Action OnUserYRot;//目标相机模式被打断

    public bool EnabledAll
    {
        set { EnabledTouch = EnabledScale = EnabledRot = value; }
    }

    public bool EnabledTouch
    {
        get { return m_EnabledTouch; }
        set { m_EnabledTouch = value; }
    }

    public bool EnabledScale
    {
        get { return m_EnabledScale; }
        set { m_EnabledScale = value; }
    }

    public bool EnabledRot
    {
        get { return m_EnabledRot; }
        set { m_EnabledRot = value; }
    }

    public bool IsObjMode {
        get { return m_WorkMode == WorkMode.Obj; }
    }

    /// <summary>
    /// 打断目标相机模式
    /// </summary>
     public void  InterruptObjMode()
    {
        if (m_WorkMode != WorkMode.Obj) return;
        m_WorkMode = WorkMode.Free;//切为自由相机模式

        StopXOffsetTweener();
        StopZOffsetTweener(); 

        if(OnInterruptObjMode!=null) OnInterruptObjMode();
    }

     void RotXTo(float xRot,Ease ease,float time=0.3f)
     {
         var x = m_TransformMixer.MainRotationTransform.Value.eulerAngles.x;
         if (QKMath.Equals(xRot, x)) return;//没有旋转的必要

         StopRotXTweener();

         if (QKMath.Equals(time, 0))
         {
             Vector3 tmpEuler = m_TransformMixer.MainRotationTransform.Value.eulerAngles;
             tmpEuler.x = xRot;
             m_TransformMixer.MainRotationTransform.Value = Quaternion.Euler(tmpEuler);
         }else
         m_rotXTweener = DOTween.To(
               () => m_TransformMixer.MainRotationTransform.Value.eulerAngles.x,
               (rot_x) =>
               {
                   Vector3 tmpEuler = m_TransformMixer.MainRotationTransform.Value.eulerAngles;
                   tmpEuler.x = rot_x;
                   m_TransformMixer.MainRotationTransform.Value = Quaternion.Euler(tmpEuler);
               },
               xRot,
               time
               ).SetAutoKill().SetEase(ease);
     }

     void MoveYTo(float newy, Ease ease,float time=0.3f)
     {
         var pos = m_ScrollObject.ScrollViewPosition;

         if (!QKMath.Equals(pos.y, newy))
         {
             StopPosYTweener();

             if (QKMath.Equals(time, 0))
             {
                 Vector3 tmpPos = m_ScrollObject.ScrollViewPosition;
                 tmpPos.y = newy;
                 m_ScrollObject.JumpTo(tmpPos);
             }
             else
             m_posYTweener = DOTween.To(
                 () => m_ScrollObject.ScrollViewPosition.y,
                 (v) =>
                 {
                     Vector3 tmpPos = m_ScrollObject.ScrollViewPosition;
                     tmpPos.y = v;
                     m_ScrollObject.JumpTo(tmpPos);
                 },
                 newy,
                 0.3f
                 ).SetAutoKill().SetEase(ease);

         }
          
     }
     void StopZOffsetTweener() { if (m_ZOffsetTweener != null && m_ZOffsetTweener.IsActive()) m_ZOffsetTweener.Kill(); }
     void StopXOffsetTweener() { if (m_XOffsetTweener != null && m_XOffsetTweener.IsActive()) m_XOffsetTweener.Kill(); }

    void StopPosXTweener()   {     if (m_posXTweener != null && m_posXTweener.IsActive()) m_posXTweener.Kill();  }

    void StopPosZTweener() { if (m_posZTweener != null && m_posZTweener.IsActive()) m_posZTweener.Kill(); }


    void XOffsetTo(float newV, Ease ease, bool constant = false, float time = 0.3f)
    { 
        StopXOffsetTweener();
        if (QKMath.Equals(time, 0))
        {
            m_CurrXOffset = newV;
            ApplyOffset();
        }
        else
            m_XOffsetTweener = DOTween.To(
                () => m_CurrXOffset,//m_ScrollObject.ScrollViewPosition.x
                (v) =>
                {
                    m_CurrXOffset = v;
                    ApplyOffset();
                },
                newV,
                time
                ).SetAutoKill().SetEase(ease); 
    }

    void ZOffsetTo(float newV, Ease ease, bool constant = false, float time = 0.3f)
    {
        StopZOffsetTweener();
        if (QKMath.Equals(time, 0))
        {
            m_CurrZOffset = newV;
            ApplyOffset();
        }
        else
            m_ZOffsetTweener = DOTween.To(
                () => m_CurrZOffset,//m_ScrollObject.ScrollViewPosition.x
                (v) =>
                {
                    m_CurrZOffset = v;
                    ApplyOffset();
                },
                newV,
                time
                ).SetAutoKill().SetEase(ease); 
    }

    void ApplyOffset()
    {
        var rotY = m_TransformMixer.MainRotationTransform.Value.eulerAngles.y;

        var rDir = Quaternion.Euler(0, rotY, 0) * Vector3.right;
        var fDir = Quaternion.Euler(0, rotY, 0) * Vector3.back;
        rDir.Normalize();
        fDir.Normalize();

        var v = m_OffsetTransform.Value;
        v = rDir * m_CurrXOffset +fDir * m_CurrZOffset;
        m_OffsetTransform.Value = v;
    }

    void MoveTo(Vector3 newpos,Ease ease,bool constant=false,float time = 0.3f)
     {
         var pos = m_ScrollObject.ScrollViewPosition;

         if (!QKMath.Equals(pos.x, newpos.x))
         {
            /*
             if (constant && m_posXTweener != null && m_posXTweener.IsActive())//持续模式，且当前tweener仍然有效 
                 //m_posXTweener.ChangeValues(m_ScrollObject.ScrollViewPosition.x, newpos.x);
                 m_posXTweener.ChangeEndValue(newpos.x);
             else*/
             {
                 StopPosXTweener();
                 if (QKMath.Equals(time, 0))
                 {
                   
                     //m_CurrXPos = newpos.x;
                     //ApplyXPos(); 
                     Vector3 tmpPos = m_ScrollObject.ScrollViewPosition;
                     tmpPos.x = newpos.x;
                     m_ScrollObject.JumpTo(tmpPos); 
                 }
                 else
                     m_posXTweener = DOTween.To(
                         () => m_ScrollObject.ScrollViewPosition.x,//m_ScrollObject.ScrollViewPosition.x
                         (v) =>
                         {
                             var tmp = m_ScrollObject.ScrollViewPosition;
                             tmp.x = v;
                             m_ScrollObject.JumpTo(tmp); 
                             //m_CurrXPos = v;
                             //ApplyXPos();
                         },
                         newpos.x,
                         time
                         ).SetAutoKill().SetEase(ease);
             }
         }

         if (!QKMath.Equals(pos.y, newpos.y))
        {
            if (constant && m_posYTweener != null && m_posYTweener.IsActive())//持续模式，且当前tweener仍然有效 
                //m_posYTweener.ChangeValues(m_ScrollObject.ScrollViewPosition.y, newpos.y);
                m_posYTweener.ChangeEndValue(newpos.y, true);
            else
            {
                StopPosYTweener();
                if (QKMath.Equals(time, 0))
                {
                    Vector3 tmpPos = m_ScrollObject.ScrollViewPosition;
                    tmpPos.y = newpos.y;
                    m_ScrollObject.JumpTo(tmpPos);
                }
                else
                    m_posYTweener = DOTween.To(
                        () => m_ScrollObject.ScrollViewPosition.y,
                        (v) =>
                        {
                            Vector3 tmpPos = m_ScrollObject.ScrollViewPosition;
                            tmpPos.y = v;
                            m_ScrollObject.JumpTo(tmpPos);
                        },
                        newpos.y,
                        0.3f
                        ).SetAutoKill().SetEase(ease);
            }

        }

        if (!QKMath.Equals(pos.z, newpos.z))
        {
            if (constant && m_posZTweener != null && m_posZTweener.IsActive())//持续模式，且当前tweener仍然有效 
                //m_posYTweener.ChangeValues(m_ScrollObject.ScrollViewPosition.y, newpos.y);
                m_posZTweener.ChangeEndValue(newpos.z, true);
            else
            {
                StopPosZTweener();

                if (QKMath.Equals(time, 0))
                {
                    Vector3 tmpPos = m_ScrollObject.ScrollViewPosition;
                    tmpPos.z = newpos.z;
                    m_ScrollObject.JumpTo(tmpPos);
                }
                else
                    m_posZTweener = DOTween.To(
                        () => m_ScrollObject.ScrollViewPosition.z,
                        (v) =>
                        {
                            Vector3 tmpPos = m_ScrollObject.ScrollViewPosition;
                            tmpPos.z = v;
                            m_ScrollObject.JumpTo(tmpPos);
                        },
                        newpos.z,
                        0.3f
                        ).SetAutoKill().SetEase(ease);
            }

        }
     }

    /// <summary>
    /// 应用x位置，合成偏移效果和位移效果
    /// </summary>
    /*void ApplyXPos()
    {
        Vector3 tmpPos = m_ScrollObject.ScrollViewPosition;
        tmpPos.x = m_CurrXPos + m_CurrXOffset;
        m_ScrollObject.JumpTo(tmpPos);
    }*/

    void StopPosYTweener()   {  if (m_posYTweener != null && m_posYTweener.IsActive()) m_posYTweener.Kill();   }

    void StopRotXTweener()  { if (m_rotXTweener != null && m_rotXTweener.IsActive()) m_rotXTweener.Kill(); }

     void StopAllTween()
     {
         StopPosXTweener();
         StopPosYTweener();
         StopPosZTweener();
         StopXOffsetTweener();
         StopRotXTweener();
         StopZOffsetTweener();
     }

    //拖拽完毕
    void OnTouchUpHandler(Gesture gesture)
    {
        m_ScrollObject.MoveEnd();

    }


    float InOutScale{
        get
        {
            return 0.005f * SData_MapData.Single.FreeCamera_Scale_Speed;
        }
    }

    float YRotScale {
        get
        {
            return YRotScaleXS * SData_MapData.Single.CameraY_XuanzhuanSpeed;
        }
    }

#if UNITY_STANDALONE_WIN //windows平台
    const float TouchScale = 0.5f;
    const float YRotScaleXS = 0.5f;
#else//其它平台
    const float TouchScale = 0.3f;
    const float YRotScaleXS = 3.6f;
#endif



    BoxScrollObject m_ScrollObject;
    TransformMixer m_TransformMixer;


    enum WorkMode
    {
        Free,//自由相机
        Obj,//跟随目标相机
    }

    Tweener m_ZOffsetTweener = null;
    Tweener m_XOffsetTweener = null;
    Tweener m_posXTweener = null;
    Tweener m_posYTweener = null;
    Tweener m_posZTweener = null;

    Tweener m_rotXTweener = null;

    WorkMode m_WorkMode = WorkMode.Free;//当前工作模式，默认自由 

    float m_CurrXOffset = 0;//当前x偏移值
    float m_CurrZOffset = 0;
    //float m_CurrXPos = 0;//当前x位移值

    PositionTransform m_OffsetTransform;
    public float m_Scale = 1;//当前缩放值
    public float m_YRotScale = 0.5f;//y轴旋转插值
    float m_ZOffset;
    float m_XOffset;

     float m_Height;
     float m_Rotation;

     public bool istuiguan = false;

    //int m_FocusHeroDataID = 0;
    //bool m_FocusIsAttack = false;
    //bool m_HasTrackPos3d = false;
    bool m_FocusObjChanged = false;
    Vector3 m_TrackPos3d;//演员3d位置
    float m_ActorDirX;//演员当前的X朝向
    bool m_EnabledTouch = true;
    bool m_EnabledScale = true;
    bool m_EnabledRot = true;
}
