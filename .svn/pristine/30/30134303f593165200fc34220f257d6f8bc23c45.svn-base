using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;

public class AstarFight : MonoBehaviour
{

    private GameObject main;

    /// <summary>
    /// 寻路X轴宽度
    /// </summary>
    public int DiameterX = 1;

    /// <summary>
    /// 寻路Y轴宽度
    /// </summary>
    public int DiameterY = 1;

    /// <summary>
    /// 随机
    /// </summary>
    //public int RandomRate = 40;

    /// <summary>
    /// 地图宽度
    /// </summary>
    public int MapWidth = 50;

    /// <summary>
    /// 地图高度
    /// </summary>
    public int MapHeight = 50;

    /// <summary>
    /// 单位宽度
    /// </summary>
    public int UnitWidth = 1;

    /// <summary>
    /// 其实x
    /// </summary>
    public int StartX = 0;

    /// <summary>
    /// 起始Y
    /// </summary>
    public int StartY = 0;

    /// <summary>
    /// 目标X
    /// </summary>
    public int TargetX = 0;

    /// <summary>
    /// 目标Y
    /// </summary>
    public int TargetY = 0;

    /// <summary>
    /// 是否提供跳点路径
    /// </summary>
    public bool IsJumpPoint = false;

    /// <summary>
    /// 地图加载
    /// </summary>
    public LoadMap LoadMap;

    /// <summary>
    /// 路径点对象
    /// </summary>
    public GameObject PathPoint;

    /// <summary>
    /// 路径点父级
    /// </summary>
    public GameObject PathPointFather;

    /// <summary>
    /// 集群引用
    /// </summary>
    public ClusterManager ClusterManager;

    /// <summary>
    /// 可下兵的最远的X坐标
    /// </summary>
    private int maxX;

    /// <summary>
    /// 以触摸点为中心循环扩大搜索半径来搜索可下兵的点，tempList记录搜索正方形范围边上的所有点
    /// </summary>
    private List<int> tempList = new List<int>();
    /// <summary>
    /// 记录同半径下所有可下兵的点，为了计算哪个点离触摸点最近
    /// </summary>
    private List<int> tempList2 = new List<int>();

    /// <summary>
    /// 创建集群个数
    /// </summary>
    public int ItemCount = 1;


    private int[][] mapInfoData;

    /// <summary>
    /// 4个触摸+敌方 5个阵型列表
    /// </summary>
    private int[][] zhenxingList = new int[5][];
    /// <summary>
    /// 当前阵型最宽的X值(单位：格子)，避免下兵时右半侧的部队可以下到最远区域外
    /// </summary>
    private int[] zhenxingMaxX = new int[5];

    void Start()
    {
        // 初始化
        Init();
    }

    /// <summary>
    /// 初始化战斗场景
    /// </summary>
    private void Init()
    {
        // TODO 文件应该从配置文件中读取
        var mapInfoPath = Application.dataPath + Path.AltDirectorySeparatorChar + "mapinfo";
        var mapInfoStr = Utils.LoadFileInfo(mapInfoPath);
        mapInfoData = DeCodeInfo(mapInfoStr);

        MapWidth = mapInfoData[0].Length;
        MapHeight = mapInfoData.Length;
        if (TargetX >= MapWidth || TargetX < 0)
        {
            TargetX = MapWidth - 1;
        }
        if (TargetY >= MapHeight || TargetY < 0)
        {
            TargetY = MapHeight - 1;
        }

        var fixtureList = LoadMap.Init(mapInfoData, UnitWidth);
        // 初始化ClusterManager
        var clusterManagerObj = new GameObject("ClusterManager");
        ClusterManager = clusterManagerObj.AddComponent<ClusterManager>();
        DontDestroyOnLoad(clusterManagerObj);
        // 初始化集群管理
        var loadMapPos = LoadMap.GetLeftBottom();
        ClusterManager.Init(loadMapPos.x, loadMapPos.z, MapWidth, MapHeight, UnitWidth, mapInfoData);

        // 将障碍物加入列表
        foreach (var fixture in fixtureList)
        {
            var fixtureBehaviour = fixture.AddComponent<FixtureData>();
            fixtureBehaviour.Diameter *= UnitWidth;
            ClusterManager.Add(fixtureBehaviour);
        }
    }


    /// <summary>
    /// 向lua返回最优的可下兵的点
    /// </summary>
    /// <param name="mp">物体起始点，我方为世界坐标，地方为格子坐标</param>
    /// <param name="index">多点触摸模式下的触摸Index，为4是为敌方</param>
    /// <returns>最优的可下兵的点</returns>
    public Vector3 isZhangAi(Vector3 mp, int index)
    {
        int[] a = new int[2];
        int spani = 1;//搜索半径
        int tempMax;
        if (index == 4)//如果为敌人
        {
            a[0] = (int)mp.x;
            a[1] = (int)mp.z;
            tempMax = 99999;
        }
        else
        {
            a = Utils.PositionToNum(LoadMap.MapPlane.transform.position, mp, UnitWidth, MapWidth, MapHeight);
            tempMax = maxX - zhenxingMaxX[index];
        }
        Vector3 tempP = Utils.NumToPosition(LoadMap.transform.position, new Vector2(a[0], a[1]), UnitWidth,
        MapWidth, MapHeight);
        //触摸点世界坐标转换为格子坐标
        float[] aC = { (tempP.x - mp.x) / UnitWidth, (tempP.z - mp.z) / UnitWidth };

        tempList2.Clear();
        while (true)
        {
            tempList.Clear();
            if (spani == 1)//半径为1时添加触摸点本身
            {
                tempList.Add(0);
                tempList.Add(0);
            }
            int a1 = -spani;
            int b1 = -spani;
            int a2 = spani;
            int b2 = spani;
            //获取搜索区域边上的点
            for (int i = 1; i < 2 * spani + 1; i++)
            {
                tempList.Add(a1);
                tempList.Add(b1 + i);
                tempList.Add(a1 + i);
                tempList.Add(b1);
                tempList.Add(a2);
                tempList.Add(b2 - i);
                tempList.Add(a2 - i);
                tempList.Add(b2);
            }
            int templ = tempList.Count;
            tempList[templ - 4] = a1;
            tempList[templ - 3] = b1;
            tempList[templ - 2] = a2;
            tempList[templ - 1] = b2;
            spani++;

            for (int i = 0; i < tempList.Count; i += 2)
            {
                //测试是否是可下兵的点
                if (testPoint(a[0] + tempList[i], a[1] + tempList[i + 1], index) && (a[0] + tempList[i]) < tempMax)
                {
                    tempList2.Add(tempList[i]);
                    tempList2.Add(tempList[i + 1]);
                }
            }

            if (tempList2.Count > 0)
            {
                float min = 9999;
                float tempFloat;
                int tempInt2 = 0;
                //计算哪个点离触摸点最近
                for (int i = 0; i < tempList2.Count; i += 2)
                {
                    tempFloat = (float)(Math.Pow(aC[0] - tempList2[i], 2) + Math.Pow(aC[1] - tempList2[i + 1], 2));
                    if (tempFloat < min)
                    {
                        min = tempFloat;
                        tempInt2 = i;
                    }
                }
                //向lua返回最优的可下兵的点
                return Utils.NumToPosition(LoadMap.transform.position, new Vector2(a[0] + tempList2[tempInt2], a[1] + tempList2[tempInt2 + 1]), UnitWidth, MapWidth, MapHeight);
            }
        }
    }

    /// <summary>
    /// 设置可下兵的最远的X坐标
    /// </summary>
    /// <param name="X">可下兵的最远的X坐标</param>
    public void setMaxX(float X)
    {
        maxX = (int)((X - LoadMap.MapPlane.transform.position.x + MapWidth * UnitWidth / 2) / UnitWidth);
    }
    /// <summary>
    /// 设置阵型list
    /// </summary>
    /// <param name="a">lua传过来的阵型数据</param>
    /// <param name="index">多点触摸模式下的触摸Index</param>
    public void setZhenxingList(int[] a, int index)
    {
        zhenxingList[index] = a;
    }


    /// <summary>
    /// 设置当前阵型最宽的X值(单位：格子)，避免下兵时右半侧的部队可以下到最远区域外
    /// </summary>
    /// <param name="a">lua传过来的最宽的X值(单位：格子)</param>
    /// <param name="index">多点触摸模式下的触摸Index</param>
    public void setZhenxingMaxX(int a, int index)
    {
        zhenxingMaxX[index] = a;

    }
    /// <summary>
    /// 向lua传回世界坐标转换为格子坐标
    /// </summary>
    /// <param name="p"></param>
    /// <returns></returns>
    public Vector3 getNum(Vector3 p)
    {
        int[] a = Utils.PositionToNum(LoadMap.MapPlane.transform.position, p, UnitWidth, MapWidth, MapHeight);
        return new Vector3(a[0], 0, a[1]);

    }


    /// <summary>
    /// 物体寻路
    /// </summary>
    /// <param name="isEnemy">是否为地方阵营</param>
    /// <param name="groupIndex">队伍index</param>
    /// <param name="go">物体GameObject</param>
    internal void toXunLu(bool isEnemy, int groupIndex, GameObject go)
    {
        //把物体当前世界坐标转换为格子坐标
        int[] a = Utils.PositionToNum(LoadMap.MapPlane.transform.position, go.transform.position, UnitWidth, MapWidth, MapHeight);
        IList<Node> path;
        if (!isEnemy)//敌我阵营的起始位置相反
        {
            path = AStarPathFinding.SearchRoad(mapInfoData, a[0], a[1], TargetX, a[1], DiameterX, DiameterY,
                IsJumpPoint);
        }
        else
        {
            path = AStarPathFinding.SearchRoad(mapInfoData, a[0], a[1], 1, a[1], DiameterX, DiameterY,
                IsJumpPoint);
        }


        ClusterData clusterData = go.AddComponent<ClusterData>();
        //TODODO
        clusterData.GroupId = groupIndex;
        clusterData.PhysicsInfo.MaxSpeed = 30;
        clusterData.RotateSpeed = 1;
        clusterData.RotateWeight = 1;
        clusterData.Diameter = 1 * UnitWidth;

        //clusterData.transform.localPosition = new Vector3((tempInt % 3) * 2, 1, tempInt / 3 * 2) + Utils.NumToPosition(LoadMap.transform.position, new Vector2(a[0], a[1]), UnitWidth, MapWidth, MapHeight);

        clusterData.Group.Target = Utils.NumToPosition(LoadMap.MapPlane.transform.position, new Vector2(path[path.Count - 1].X, path[path.Count - 1].Y), UnitWidth, MapWidth, MapHeight);
        this.ClusterManager.Add(clusterData);

        Action<SchoolGroup> lambdaComplete = (thisGroup) =>
        {
            //Debug.Log("GroupComplete:" + thisGroup.Target);
            // 数据本地化
            // 数据结束
            if (path.Count == 0)
            {
                return;
            }
            path.RemoveAt(path.Count - 1);
            if (path.Count == 0)
            {
                return;
            }
            var node = path[path.Count - 1];
            thisGroup.Target = Utils.NumToPosition(LoadMap.MapPlane.transform.position, new Vector2(node.X, node.Y), UnitWidth, MapWidth, MapHeight);
        };
        clusterData.Group.ProportionOfComplete = 1;
        clusterData.Group.Complete = lambdaComplete;
    }

    /// <summary>
    /// //测试是否是可下兵的点
    /// </summary>
    /// <param name="a0"></param>
    /// <param name="a1"></param>
    /// <param name="index">多点触摸模式下的触摸Index，为4是为敌方</param>
    /// <returns></returns>
    private bool testPoint(int a0, int a1, int index)
    {
        int an = zhenxingList[index].Length;
        int x, y;
        for (int i = 0; i < an; i += 2)
        {
            x = a0 + zhenxingList[index][i];
            y = a1 + zhenxingList[index][i + 1];
            if (x > -1 && y > -1 && x < MapWidth && y < MapHeight && mapInfoData[y][x] == 1)
            {
                return false;
            }
        }
        return true;
    }

    /// <summary>
    /// TODO 解码地图数据
    /// </summary>
    /// <param name="mapInfoJson">地图数据json</param>
    /// <returns>地图数据数组</returns>
    private int[][] DeCodeInfo(string mapInfoJson)
    {
        if (string.IsNullOrEmpty(mapInfoJson))
        {
            return null;
        }
        //var mapData = new List<List<int>>();
        // 读出数据
        var mapLines = mapInfoJson.Split('\n');

        int[][] mapInfo = new int[mapLines.Length - 1][];
        for (var row = 0; row < mapLines.Length; row++)
        {
            var line = mapLines[row];
            if (string.IsNullOrEmpty(line))
            {
                continue;
            }
            var cells = line.Split(',');
            // Debug.Log(line);
            mapInfo[row] = new int[cells.Length];
            for (int col = 0; col < cells.Length; col++)
            {
                if (string.IsNullOrEmpty(cells[col].Trim()))
                {
                    continue;
                }
                //Debug.Log(cells[col]);
                mapInfo[row][col] = int.Parse(cells[col]);
            }
        }

        return mapInfo;
    }

}