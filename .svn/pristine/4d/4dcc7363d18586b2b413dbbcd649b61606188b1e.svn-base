using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class UISysParticleQue : MonoBehaviour 
{
    public UIWidget widget;
    public UIPanel panel;
    public int renderQueue = 3000;
    public bool mInitFlag = false;
    public int m_AddQueue = 0;//这个数值是因为实际渲染顺序可能比父级的渲染顺序要大，这个值是附加的，如果这个脚本附加的粒子的父级的widget很层级很高的话，这个值可以不设置
    void Start()
    {
        mInitFlag = false;
        if (panel == null)
        {
            panel = gameObject.GetComponentInParent<UIPanel>();
        }
        if(widget == null)
        {
            widget = gameObject.GetComponentInParent<UIWidget>();
        }
        if (widget != null && widget.drawCall != null && mInitFlag == false)
        {
            //mInitFlag = true;//注掉这行是因为想让update函数再重新计算一次
            FixRenderQueue(true);
        }
    }
    void Update()
    {
        //if (widget != null && widget.drawCall != null && mInitFlag == false)
        if (mInitFlag == false)
        {
            mInitFlag = true;
            FixRenderQueue(true);
        }
    }
    private List<ParticleSystem> mListParticleSystem = new List<ParticleSystem>();
    private List<MeshRenderer> mListMeshRenderer = new List<MeshRenderer>();
    public void FixRenderQueue(bool reset)
    {
       // Profiler.BeginSample("ParticleSystem:FixRenderQueue");
        if (reset == true)
        {
            if (widget != null && widget.drawCall != null)
            {
                //widget.drawCall.AddFixParticle(this);
                renderQueue = widget.drawCall.renderQueue + m_AddQueue;
            }
            else if (panel != null)
            {
                renderQueue = panel.startingRenderQueue + m_AddQueue;
            }
            mListParticleSystem.Clear();
            mListMeshRenderer.Clear();
            ParticleSystem[] pars = this.GetComponentsInChildren<ParticleSystem>(true);
            if (pars != null && pars.Length > 0)
            {
                for (int i = 0, max = pars.Length; i < max; i++)
                {
                    ParticleSystem par = pars[i];
                    Renderer render = par.gameObject.GetComponent<Renderer>();
                    if (render != null && render.sharedMaterial != null)
                    {
                        render.sharedMaterial.renderQueue = renderQueue;
                        //Debug.LogError("===========renderQueue======" + renderQueue);
                        mListParticleSystem.Add(par);
                    }
                   
                }
            }
            MeshRenderer[] meshs = this.GetComponentsInChildren<MeshRenderer>(true);
            if (meshs != null && meshs.Length > 0)
            {
                for (int i = 0, max = meshs.Length; i < max; i++)
                {
                    MeshRenderer mesh = meshs[i];
                    if (mesh != null && mesh.material != null)
                    {
                        mesh.material.renderQueue = renderQueue;
                        //Debug.LogError("===========renderQueue==sss====" + renderQueue);
                        mListMeshRenderer.Add(mesh);
                    }
                   
                }
            }
        }
        else
        {
            if (mListParticleSystem.Count < 1 || mListMeshRenderer.Count < 1)
            {
                FixRenderQueue(true);
            }
            else
            {
                bool needRefresh = false;
                if (widget != null && widget.drawCall != null)
                {
                    if (renderQueue != widget.drawCall.renderQueue)
                    {
                        renderQueue = widget.drawCall.renderQueue+m_AddQueue;
                        needRefresh = true;
                    }
                }
                else if (panel != null)
                {
                    if (renderQueue != panel.startingRenderQueue)
                    {
                        renderQueue = panel.startingRenderQueue + m_AddQueue;
                        needRefresh = true;
                    }
                }
                if (needRefresh == true)
                {
                    if (mListParticleSystem != null && mListParticleSystem.Count > 0)
                    {
                        for (int i = mListParticleSystem.Count - 1; i >= 0; i--)
                        {
                            ParticleSystem par = mListParticleSystem[i];
                            if (par != null)
                            {
                                Renderer render = par.gameObject.GetComponent<Renderer>();
                                if (render != null && render.material != null)
                                {
                                    render.material.renderQueue = renderQueue;
                                    //Debug.LogError("===========renderQueue==ddd====" + renderQueue);
                                    //par.renderer.material.renderQueue = renderQueue;
                                }
                            }
                            else
                            {
                                mListParticleSystem.RemoveAt(i);
                            }
                        }
                    }
                    if (mListMeshRenderer != null && mListMeshRenderer.Count > 0)
                    {
                        for (int i = mListMeshRenderer.Count - 1; i >= 0; i--)
                        {
                            MeshRenderer mesh = mListMeshRenderer[i];
                            if (mesh != null && mesh.material != null)
                            {
                                mesh.material.renderQueue = renderQueue;
                                //Debug.LogError("===========renderQueue==ccccccc====" + renderQueue);
                            }
                            else
                            {
                                mListMeshRenderer.RemoveAt(i);
                            }
                        }
                    }
                }
            }
        }
        //Profiler.EndSample();
    }
    public void ResetRenderQueue()
    {
        FixRenderQueue(true);
    }

}
