using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UniLua;
using UnityEngine;

class LuaTimerLib
{
    class CMTimerInfo : ICoreComponentInfo
    {
        public Type type { get { return typeof(UTimer); } }
        public string name { get { return LuaTimerLib.LIB_NAME; } }
        public void newLuaObj(ILuaState lua, Component cmp)
        {
            LuaTimerLib._wrap(lua, cmp as UTimer);
        }
    }


    static LuaClassRegHelper m_ClassRegHelper = new LuaClassRegHelper();

    public const string LIB_NAME = "CMTimer";
    public static int OpenLib(ILuaState lua)
    {

        //注册成员函数
        NameFuncPair[] member_define = new NameFuncPair[]
        {
             new NameFuncPair("Kill",M_Kill), 
             new NameFuncPair("GetState",M_GetState), 
             new NameFuncPair("IsKilld",M_IsKilld), 
             new NameFuncPair("OnComplete",M_OnComplete), 
             new NameFuncPair("OnKill",M_OnKill), 
             new NameFuncPair("Reset",M_Reset), 
        };

        NameFuncPair[] operator_define = new NameFuncPair[]
        {
           
        };

        m_ClassRegHelper.RegMembers(lua, member_define, operator_define);


        //注册静态成员
        NameFuncPair[] static_define = new NameFuncPair[]
        {  
        };

        //注册静态属性
        NameValuePair[] static_property = new NameValuePair[]
        {
            new NameValuePair("Name",LIB_NAME),
        };
        m_ClassRegHelper.RegStatics(lua, static_define, static_property);


        
        NameValuePair[] enum_TimerState = new NameValuePair[]
        {
            new NameValuePair("killd",MonoEX.Timer.STATE.killd),
            new NameValuePair("paused",MonoEX.Timer.STATE.paused),
            new NameValuePair("played",MonoEX.Timer.STATE.played),
        };
        m_ClassRegHelper.RegEnum(lua, "TimerState",enum_TimerState);


        LuaGameObjectLib.RegComponent(new CMTimerInfo());

        return 1;
    }


    public static void _wrap(ILuaState lua, UTimer comp)
    {
        LuaOpenLibs._wrapComponent(lua, comp, LIB_NAME, m_ClassRegHelper);
    }

    public static UTimer Lua2Obj(ILuaState lua, int index)
    {
        LuaMemberHelper.CheckClass(lua, index);

        return LuaMemberHelper.GetObject<UTimer>(lua, index, LuaOpenLibs.OBJ_HANDELNAME);
    }
     
     
    static int M_Kill(ILuaState lua)
    {
        //in self
        //out self
        UTimer self = Lua2Obj(lua,1);
        self.TimerHandel.Kill();
        _wrap(lua, self);
        return 1;
    }

    

    static int M_GetState(ILuaState lua)
    {
        //in self
        //out TimerState
        UTimer self = Lua2Obj(lua, 1);
        lua.PushInteger((int)self.TimerHandel.state);
        return 1;
    }

    static int M_IsKilld(ILuaState lua)
    {
        //in self
        //out bool
        UTimer self = Lua2Obj(lua, 1);
        lua.PushBoolean(self.TimerHandel.IsKilld);
        return 1;
    }

    static int M_OnComplete(ILuaState lua)
    {
        //in self,recallClass,recallFunc
        //out self

        UTimer self = Lua2Obj(lua, 1);
        TimerEvts evts = TimerEvts.GetEvts(self);
        if (evts == null) { _wrap(lua, self); return 1; }

        evts.OnComplete = LuaRoot.LDelegate2Event<LuaEventCallback>(lua, 2, 3);

        _wrap(lua, self);
        return 1;
    }
    
    static int M_Reset(ILuaState lua)
    {
        //in self,live
        //out self
        UTimer self = Lua2Obj(lua, 1);
        float live = (float)lua.L_CheckNumber(2);
        self.Reset(live);
        _wrap(lua, self);
        return 1;
    }

    static int M_OnKill(ILuaState lua)
    {
        //in self,recallClass,recallFunc
        //out self

        UTimer self = Lua2Obj(lua, 1);
        TimerEvts evts = TimerEvts.GetEvts(self);
        if (evts == null) { _wrap(lua, self); return 1; }

        evts.OnKill = LuaRoot.LDelegate2Event<LuaEventCallback>(lua, 2, 3);

        _wrap(lua, self);
        return 1;
    }
}




class TimerEvts
{
    public TimerEvts(UTimer timer)
    {
        _owner = timer;
        _owner.OnKill+=OnTimerKill;
        _owner.OnComplete+=OnTimerComplete;
    }

    public QKEvent OnKill
    {
        get { return _OnKill; }
        set
        {
            if (_OnKill == value) return;
            if (_OnKill != null) _OnKill.Dispose();
            _OnKill = value;
        }
    }

    public QKEvent OnComplete
    {
        get { return _OnComplete; }
        set
        {
            if (_OnComplete == value) return;
            if (_OnComplete != null) _OnComplete.Dispose();
            _OnComplete = value;
        }
    }

    public void OnTimerComplete()
    {
        if (_OnComplete != null) _OnComplete.Call(null);
    }

    public void OnTimerKill()
    {
        OnComplete = null;

        //foreach (LuaEvent currEvt in _OtherEvts) currEvt.Dispose();//销毁所有绑定的事件
        //_OtherEvts.Clear();
        _owner.OnKill -= OnTimerKill;
        _owner.OnComplete -= OnTimerComplete;

        m_TimerEvts.Remove(_owner);
        _owner = null;

        if (_OnKill != null) { _OnKill.Call(null); OnKill = null; }
    }

    //public void AddOtherEvt(LuaEvent evt) { _OtherEvts.Add(evt); }
    
    public static TimerEvts GetEvts(UTimer timer)
    {
        if (timer==null) return null;//已经被干掉的
        if (m_TimerEvts.ContainsKey(timer)) return m_TimerEvts[timer];

        TimerEvts re = new TimerEvts(timer);
        m_TimerEvts.Add(timer, re);
        return re;
    }



    UTimer _owner;
    QKEvent _OnKill = null;
    QKEvent _OnComplete = null;
    //List<LuaEvent> _OtherEvts = new List<LuaEvent>();

    static Dictionary<UTimer, TimerEvts> m_TimerEvts = new Dictionary<UTimer, TimerEvts>();
}