using UnityEngine;
using System.Collections;
using System.Collections.Generic;
// <summary>
/// 云朵点击事件
/// </summary>
static class QuadEvent
{
    /// <summary>
    /// 云朵点击事件
    /// </summary>
    public static event onQuadClick OnQuadClick;
    public static void PostQuadClick(QKUIQuad result)
    {
        if (OnQuadClick != null)
            OnQuadClick(result);
    }

    public delegate void onQuadClick(QKUIQuad result);
} 
[RequireComponent(typeof(MeshFilter))]
[RequireComponent(typeof(MeshCollider))]
[RequireComponent(typeof(UITexture))]
//点击获得UV注意，模型必须带有uv，如果模型放大缩小，碰撞盒也必须放大缩小
[ExecuteInEditMode]
public class QKUIQuad : MonoBehaviour
{
    private Vector2 topPoint;
    private Vector2 bottomPoint;
    private Vector2 leftPoint;
    private Vector2 rightPoint;
    public Vector2 m_mapSize = new Vector2(5632,3584);
    private Mesh m_mesh;
    private MeshCollider m_meshCollider;
    private UIWidget m_widget;
    private UITexture m_tex;

    public Color changeColor;
    public float colorShow = 1;
    public  int m_ID;
    public bool isShowLine;
    static Dictionary<int, QKUIQuad> m_quadDict = new Dictionary<int, QKUIQuad>();
    public static bool isOpen = true;
    void Start()
    {

        topPoint = new Vector2(0f, 0f);
        bottomPoint = new Vector2(1f, 1f);
        leftPoint = new Vector2(1f, 0f);
        rightPoint = new Vector2(0f, 1f);
        MeshFilter meshFilter = gameObject.GetComponent<MeshFilter>();

        if (meshFilter == null)
        {
            //Debug.LogError("Script needs MeshFilter component");
            return;
        }
        //重新设置模型顶点
        List<Vector3> tempV = new List<Vector3>();
        tempV.Add(new Vector3(-0.5f, -0.5f, 0f));
        tempV.Add(new Vector3(0.5f, 0.5f, 0f));
        tempV.Add(new Vector3(0.5f, -0.5f, 0f));
        tempV.Add(new Vector3(-0.5f, 0.5f, 0f));

        Vector2[] uv = new Vector2[4];
        uv[0] = topPoint;
        uv[1] = bottomPoint;
        uv[2] = leftPoint;
        uv[3] = rightPoint;

        int[] temptris = new int[6];
        temptris[0] = 0;
        temptris[1] = 1;
        temptris[2] = 2;
        temptris[3] = 1;
        temptris[4] = 0;
        temptris[5] = 3;
        //自己创建防止meshFilter引用的mesh没有
        meshFilter.sharedMesh = new Mesh();
        meshFilter.sharedMesh.vertices = tempV.ToArray();
        meshFilter.sharedMesh.triangles = temptris;
        meshFilter.sharedMesh.uv = uv;

        m_meshCollider = gameObject.GetComponent<MeshCollider>();
        m_widget = gameObject.GetComponent<UIWidget>();
        m_tex = gameObject.GetComponent<UITexture>();

#if UNITY_EDITOR
        //Mesh meshCopy = Mesh.Instantiate(meshFilter.sharedMesh) as Mesh; // Make a deep copy
        //meshCopy.name = "Que";
        //m_mesh = meshFilter.mesh = meshCopy; // Assign the copy to the meshes
        m_mesh = meshFilter.sharedMesh;

#else
        //在编辑模式下使用meshFilter.mesh，This will leak meshes
        m_mesh = meshFilter.mesh;
#endif
        UpdateMeshUVS();

        // //以下是根据数值进行缩放
        List<Vector3> verts = new List<Vector3>();
        List<int> tris = new List<int>();
        for (int i = 0; i < m_mesh.vertices.Length; ++i)
        {
            Vector3 v = new Vector3(m_mesh.vertices[i].x * m_widget.width, m_mesh.vertices[i].y * m_widget.height, transform.localPosition.z-m_widget.depth*0.01f);
            verts.Add(v);

        }
        List<Vector3> verts2 = new List<Vector3>();
        for (int i = 0; i < verts.Count; ++i)
        {
            Vector3 v = new Vector3(verts[i].x, verts[i].y, verts[i].z - 5);
            verts2.Add(v);
        }
        m_mesh.vertices = verts.ToArray();
        meshFilter.sharedMesh.vertices = verts.ToArray();
        // //修改碰撞盒的大小
        m_meshCollider.sharedMesh = m_mesh;

        //开始初始化数据
        m_meshCollider.sharedMesh.vertices = verts2.ToArray();
        m_ID = int.Parse(gameObject.name.Substring(5, gameObject.name.Length - 5));
       
        SetColorID(m_ID);
        m_meshCollider.enabled = false;
        m_tex.onRender += SetShaderInfo;
        gameObject.layer = LayerMask.NameToLayer(QKUIClickColor.layer);


        if (!isOpen)
        {
            string str = GetAllIDColor();
            Debug.LogError(str);
            isOpen = true;
        }
        gameObject.layer = LayerMask.NameToLayer("Quad");
    }
    void Update()
    {
#if UNITY_EDITOR
        //实时更新uv坐标。在实际使用中用不到。因为不会移动位置
        //gameObject.layer = LayerMask.NameToLayer("Quad");
        //UpdateMeshUVS();
#endif
    }
    void UpdateMeshUVS()
    {
        Vector2[] uvs = m_mesh.uv;
        // Front
        SetFaceTexture(uvs);

        m_mesh.uv = uvs;
    }
    Vector2[] temp_uvs = new Vector2[4];
    Vector2[] GetUVS()
    {
       

        if (m_widget != null)
        {
            int wid = m_widget.width;

            Vector3 LB = transform.localPosition + new Vector3(-m_widget.width / 2, -m_widget.height / 2, 0);
            Vector3 RT = transform.localPosition + new Vector3(m_widget.width / 2, m_widget.height / 2, 0);
            Vector3 LT = transform.localPosition + new Vector3(-m_widget.width / 2, m_widget.height / 2, 0);
            Vector3 RB = transform.localPosition + new Vector3(m_widget.width / 2, -m_widget.height / 2, 0);
            LB.y = m_mapSize.y + LB.y;
            RT.y = m_mapSize.y + RT.y;
            LT.y = m_mapSize.y + LT.y;
            RB.y = m_mapSize.y + RB.y;
            ////uv的坐标和界面的坐标y轴是相反的
            //hitpos.y = m_MapSize.y + hitpos.y;
            //Debug.LogError("===m_tex==hitpos===" + hitpos.ToString());
            ////计算出uv坐标，获取贴图的颜色
            //Vector2 pixelUV3 = new Vector2(hitpos.x / m_MapSize.x, hitpos.y / m_MapSize.y);

            temp_uvs[0] = new Vector2(LB.x / m_mapSize.x, LB.y / m_mapSize.y);
            temp_uvs[1] = new Vector2(RT.x / m_mapSize.x, RT.y / m_mapSize.y);
            temp_uvs[2] = new Vector2(LT.x / m_mapSize.x, LT.y / m_mapSize.y);
            temp_uvs[3] = new Vector2(RB.x / m_mapSize.x, RB.y / m_mapSize.y);
            if (m_tex != null)
            {
                //计算当前widget所在的位置和相对大地图的uv坐标。
                Rect rect = new Rect(temp_uvs[0].x, temp_uvs[0].y, m_widget.width / m_mapSize.x, m_widget.height / m_mapSize.y);
                m_tex.uvRect = rect;
            }

        }


        temp_uvs[0] = topPoint;
        temp_uvs[1] = bottomPoint;
        temp_uvs[2] = leftPoint;
        temp_uvs[3] = rightPoint;
        return temp_uvs;
    }
    void SetFaceTexture(Vector2[] uvs)
    {
        Vector2[] newUVS = GetUVS();
        uvs[0] = newUVS[0];
        uvs[1] = newUVS[1];
        uvs[2] = newUVS[2];
        uvs[3] = newUVS[3];

    }
    public void SetShaderInfo(Material mat)
    {
        //Debug.LogError("SetShaderInfo=" );
        if (mat != null)
        {
            //Debug.LogError("SetShaderInfo=mat != null");
            //Shader s = Shader.Find("QK/Cloud");
            ////Shader.SetGlobalColor("Color", c);
            //Material mat = m_tex.material;
            //mat.shader = s;
            //Debug.LogError("SetShaderInfo" + changeColor.ToString());
            mat.SetColor("_Color", changeColor);
            mat.SetFloat("_Show", colorShow);
            if(isShowLine)
                mat.SetFloat("_ShowID", 1.0f);
            else
                mat.SetFloat("_ShowID", 0.5f);

            mat.SetFloat("_Show", 0);
            mat.SetFloat("_ShowID",0);
            // m_tex.shader = Shader.Find("QK/Cloud");
        }
    }
    public void SetSize(int w, int h)
    {
        if (m_widget != null)
        {
            m_widget.width = w;
            m_widget.height = h;
            UpdateMeshUVS();
            //Debug.LogError("QKUIQuad SetSize == " + w + "===" + h);
        }
        else
        {
            //Debug.LogError("QKUIQuad SetSize == " + w + "===" + h);
        }
    }
    //注意：这里有一个需要注意的如果不能点击则不显示m_tex的贴图信息，这样可以减少drawcall数量。如果要设置可点击，可以把贴图单独拆开来设置
    public void SetColliderEnable(bool isEnable)
    {
        if (m_meshCollider != null)
        {
            m_meshCollider.enabled = isEnable;
            if (m_tex != null)
            {
                UpdateMeshUVS();
                m_tex.enabled = isEnable;
                if (isEnable)
                {
                    ModifyPartTex.Single.InitPart(QKUIClickColor.Single.m_tex, m_tex, m_ID, 3, TTType.TT_NEI, 0, 1);
                    ModifyPartTex.Single.StartCalcPart();
                }
               
            }
        }
        //else
          //  Debug.LogError("SetColliderEnable m_meshCollider is null == " + m_ID);
    }
    //省的ID
    public void SetColorID(int ID)
    {
        //颜色值是0-255顾每递增一次用51来增加，这样每个颜色值有5个选项，一共可以调出125个颜色值
        //全是0则表示空白不属于任何区域

        if (ID > 0)
        {

            m_ID = ID;
            int r = ID / 36;
            int g = ID % 36 / 6;
            int b = ID % 6;
            // 51/255 == 0.2f
            changeColor = new Color(r * 0.2f, g * 0.2f, b * 0.2f, 1.0f);
            if (!m_quadDict.ContainsKey(ID))
            {
                m_quadDict.Add(ID, this);
            }
            else
            {
                if (m_quadDict[ID] != this)
                {
                    m_quadDict.Remove(ID);
                    m_quadDict[ID] = this;
                }
            }
           // Debug.LogError("QKUIQuad setColorID iID == " + ID + "===" + changeColor + " " + r * 255 + " " + g * 255 + " " + b * 255 + " ");
        }
        else
        {
            //Debug.LogError("QKUIQuad setColorID id is err id == " + ID);
        }
    }
    //省的ID
    public string GetAllIDColor()
    {
        string str = "";
        for (int i = 0; i < 216;++i )
        {
            int r = i / 36;
            int g = i % 36 / 6;
            int b = i % 6;
            // 51/255 == 0.2f
            Color c = new Color(r * 0.2f, g * 0.2f, b * 0.2f, 1.0f);
            str = str + "[" + i + "] = " + c.r * 255 + " " + c.g * 255 + " " + c.b * 255 + "                  " + c + "\n";
        }
        return str;      
    }
    public static int GetColorID(Color c)
    {
        //颜色值是0-255顾每递增一次用51来增加，这样每个颜色值有5个选项，一共可以调出125个颜色值
        //全是0则表示空白不属于任何区域

        int r = (int)(c.r * 5);
        int g = (int)( c.g * 5);
        int b = (int)(c.b * 5);

        int ID = b + g * 6 + r * 36;
        return ID;
    }
    public void PlayAction()
    {
        if (m_widget != null)
            m_widget.alpha = 1.0f;
        TweenAlpha ta = gameObject.GetComponent<TweenAlpha>();
        if(ta != null)
        {
            ta.enabled = true;
        }
    }
    public static QKUIQuad Get(int id)
    {
        if (m_quadDict.ContainsKey(id))
            return m_quadDict[id];
        return null;
    }
    void OnDestroy()
    {
        if (m_quadDict != null&& m_quadDict.ContainsKey(m_ID))
            m_quadDict.Remove(m_ID);
    }
    
}