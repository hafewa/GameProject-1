using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEditor;
using System.IO;
//using QKCommon;

public class UI_BuildConfigs : EditorWindow
{
    static private UI_BuildConfigs window = null;
    private static TextAsset asset;
    [MenuItem("Tools/Configs Generate", false, 1200)]
    static void QKTools_BuildConfigs()
    {
        //创建窗口
        Rect wr = new Rect(0, 0, 500, 300);
        window = (UI_BuildConfigs)EditorWindow.GetWindowWithRect(typeof(UI_BuildConfigs), wr, true, "Build Configs");
        window.Show();
    }

    public UI_BuildConfigs()
    {
        //m_MissionIt = Do();
    }

    void Update()
    {
        if (m_MissionIt != null && !m_MissionIt.MoveNext()) { m_MissionIt = null; this.Close(); }
    }
    static private bool m_isForceMove = false;
    void OnGUI()
    {
        //this.ShowNotification(new GUIContent("正在构建资源，请勿关闭本界面.\n构建进度见底部状态栏.\n任务完成本窗口将自动关闭"));
        m_isForceMove = EditorGUILayout.ToggleLeft(new GUIContent("强制转换全部"), m_isForceMove);
        GUILayout.Space(10);
        if (GUILayout.Button("CSV转游戏数据格式", GUILayout.Width(140)))
        {
            m_MissionIt = Do();
            //关闭窗口
            //this.Close();
        }
    }

    IEnumerator m_MissionIt = null;

    internal static IEnumerator Do()
    {
        String[] filterEXNames = new String[1];
        filterEXNames[0] = ".csv";

        Debug.Log("正在统计需要处理的文件...");
        string clientOutPath = Path.Combine(Application.dataPath, "Lua/pk_tabs");
        string csOutPath = Path.Combine(Application.dataPath, "Logic/Script/YQ2Common/sdata");
        string csvPath = Path.Combine(Application.dataPath, "../csv");
        List<FileInfo> files = new List<FileInfo>();
        yield return null;
        FindFiles(new DirectoryInfo(csvPath), filterEXNames, files);//找出需要处理的文件

        asset = (TextAsset)Resources.Load("sdata_template", typeof(TextAsset));

        int jd_max = files.Count;
        int currjd = 1;
        foreach (FileInfo curr in files)
        {
            Debug.Log(String.Format("正在处理 {1}/{2} {0}", curr.Name, currjd++, jd_max));
            yield return null;
            //检查文件是否需要导出
            string name = curr.Name.Substring(0, curr.Name.Length - curr.Extension.Length);
            string cout = Path.Combine(clientOutPath, name + ".lua");
            string csout = Path.Combine(csOutPath, "SData_" + name + ".cs");
            FileInfo cFileInfo = new FileInfo(cout);
            FileInfo csFileInfo = new FileInfo(csout);

            bool need_c = false;
            bool need_cs = false;

            if (!cFileInfo.Exists)
                need_c = true;
            else
            {
                if (curr.LastWriteTime > cFileInfo.LastWriteTime)//csv文件修改日期晚于bytes
                    need_c = true;
            }

            if (!csFileInfo.Exists)
                need_cs = true;
            else
            {
                if (curr.LastWriteTime > csFileInfo.LastWriteTime)//csv文件修改日期晚于bsv
                    need_cs = true;
            }
            if (!need_c && !m_isForceMove) continue;//无需转换
            Encoding encoding = FileEncoding.GetType(curr.FullName);
            String fileContent = FileEncoding.GetFileContent(encoding, curr.FullName);

            if (encoding != Encoding.UTF8)
            {
                fileContent = FileEncoding.ToUTF8(encoding, fileContent);
            }

            //进行转换
            {
                CSVDoc doc;
                columInfo[] cInfos;
                int MainKeyIndex;
                string MainKey;
                string csvMainKey;
                bool parseOK = ParseHead(curr.FullName, fileContent, out doc, out cInfos, out MainKeyIndex, out MainKey, out csvMainKey);
                if (!parseOK) continue;

                if (need_c || m_isForceMove)
                    conversionLua(cout, doc, cInfos, MainKeyIndex, MainKey, csvMainKey);


                //if (need_cs || m_isForceMove)
                //    conversionCs(csout, name, MainKey, cInfos);



                dumpHeadInfo(curr.FullName, cInfos);
            }

        }



        Debug.Log("导出任务已完成");

        //window.Close();
    }




    static bool ParseHead(string csvpath, string csvContent, out CSVDoc doc, out columInfo[] cInfos, out int MainKeyIndex, out string MainKey, out string csvMainKey)
    {
        cInfos = null;
        List<columInfo> _cInfos = new List<columInfo>();
        doc = new CSVDoc();
        doc.LoadCsvFromMem(csvContent);

        int columnCount = doc.ColCount;

        MainKeyIndex = -1;
        csvMainKey = MainKey = "";

        int bsvIndex = 0;
        for (int c = 0; c < columnCount; c++)
        {
            string columName = doc[1, c + 1];
            int idx = columName.IndexOf("$");
            if (idx < 0) continue;

            BTabValueType valueType;
            switch (columName.Substring(0, idx))
            {
                case "I32":
                    valueType = BTabValueType.I32;
                    break;
                case "I16":
                    valueType = BTabValueType.I16;
                    break;
                case "F":
                    valueType = BTabValueType.F;
                    break;
                case "S":
                    valueType = BTabValueType.S;
                    break;
                default:
                    continue;
            };

            bool isMainKey = false;
            int startI = idx + 1;
            //if (columName[startI] == '$')//这是一个主键
            //{
            //    startI++;
            //    isMainKey = true;

            //}
            if (c == 0)//这是一个主键
            {
                isMainKey = true;
            }

            string bsvcname = columName.Substring(startI, columName.Length - startI);

            int bsvIdx = bsvIndex++;
            _cInfos.Add(
                new columInfo() { bsvIdx = bsvIdx, csvIdx = c, csvName = columName, bsvName = bsvcname, valueType = valueType }
                );

            if (isMainKey)
            {
                if (MainKeyIndex >= 0)
                {
                    Debug.Log(String.Format("表存在重复的主健 {0}", csvpath));
                    return false;
                }
                MainKeyIndex = bsvIdx;
                MainKey = bsvcname;
                csvMainKey = columName;
            }
        }



        if (_cInfos.Count < 1) return false;//没有任何字段

        cInfos = _cInfos.ToArray();
        return true;
    }

    static void dumpHeadInfo(string csvPath, columInfo[] cInfos) //输出表字段名和类型对照表
    {
        string csvFileName = csvPath.Substring(0, csvPath.Length - 4);
        String oPath = csvFileName + ".txt";
        using (FileStream fs = new FileStream(oPath, FileMode.Create))
        {
            //写入更新时间
            var now = DateTime.Now;
            var strDate = string.Format("{0:d4}{1:d2}{2:d2}{3:d2}{4:d2}{5:d2}\r\n", now.Year, now.Month, now.Day, now.Hour, now.Minute, now.Second);
            var bytesDate = Encoding.UTF8.GetBytes(strDate);
            fs.Write(bytesDate, 0, bytesDate.Length);

            //开始写入字段数据
            foreach (columInfo curr in cInfos)
            {
                string vTypeStr = "";
                switch (curr.valueType)
                {
                    case BTabValueType.F:
                        vTypeStr = "F";
                        break;
                    case BTabValueType.I16:
                        vTypeStr = "I16";
                        break;
                    case BTabValueType.I32:
                        vTypeStr = "I32";
                        break;
                    case BTabValueType.S:
                        vTypeStr = "S";
                        break;
                }
                byte[] buffer = Encoding.UTF8.GetBytes(string.Format("{0} {1}\r\n", curr.bsvName, vTypeStr));
                fs.Write(buffer, 0, buffer.Length);
            }

            //清空缓冲区、关闭流  
            fs.Flush();
            fs.Close();
        }
    }



    static void conversionLua(string outpath, CSVDoc doc, columInfo[] cInfos, int MainKeyIndex, string MainKey, string csvMainKey)
    {

        //生成lua表
        if (MainKeyIndex < 0)
            return;//无主健不能生成

        {
            using (FileStream fs = new FileStream(outpath, FileMode.Create))
            {
                using (StreamWriter sw = new StreamWriter(fs))
                {
                    sw.WriteLine("local data ={");

                    string keytypestr = cInfos[MainKeyIndex].valueType == BTabValueType.S ? "keytype.str" : "keytype.int";
                    sw.WriteLine(
                            string.Format("\tinfo={{key=\"{0}\",keytype={1}}},",
                                MainKey,
                                keytypestr
                            )
                        );

                    string headstr = "";
                    foreach (columInfo cinfo in cInfos)
                    {
                        string n = "\"" + cinfo.bsvName + "\"";
                        if (headstr == "")
                            headstr = n;
                        else
                            headstr += "," + n;
                    }

                    sw.WriteLine(string.Format("\thead={{{0}}},", headstr));
                    sw.WriteLine("\tbody={");

                    BTabValueType mKtype = cInfos[MainKeyIndex].valueType;
                    CSVReader reader = new CSVReader(doc);
                    while (reader.Read())
                    {
                        string vstr = "";
                        foreach (columInfo curr in cInfos)
                        {
                            string v = reader[curr.csvName];
                            string writeV = curr.valueType == BTabValueType.S ? "\"" + LuaString(v) + "\"" : v;
                            if (vstr == "")
                                vstr = writeV;
                            else
                                vstr += "," + writeV;
                        }

                        string rkey = reader[csvMainKey];
                        if (mKtype != BTabValueType.S)
                            rkey = "[" + rkey + "]";
                        else
                            rkey = "[\"" + LuaString(rkey) + "\"]";
                        sw.WriteLine(string.Format("\t\t{0}={{{1}}},", rkey, vstr));
                    }
                    sw.WriteLine("\t}");//end body
                    sw.WriteLine("}");//end data
                    sw.WriteLine("return data");
                }
            }

        }

    }

    /// <summary>
    /// 转换成lua字符串，转义
    /// </summary>
    /// <param name="str"></param>
    /// <returns></returns>
    static string LuaString(string str)
    {
        str = str.Replace("\\", "\\\\");
        str = str.Replace("\"", "\\\"");
        str = str.Replace("\\\\n", "\\n");
        return str;
    }



    static void conversionBsv(string outpath, CSVDoc doc, columInfo[] cInfos)
    {

        //using (
        BTab tab = new BTab();
        //)
        {
            //创建bsv表头
            foreach (columInfo curr in cInfos)
            {
                if (tab.AddColumn(curr.bsvName, curr.valueType) == null) { Debug.LogError(string.Format("{0} 字段重复 {1}", outpath, curr.bsvName)); return; }
            }

            //行数据缓存
            // object[] row = new object[cInfos.Length];
            List<string> row = new List<string>();
            //Debug.Log("cInfos.Length:" + cInfos.Length.ToString());

            //增加行
            CSVReader reader = new CSVReader(doc);
            while (reader.Read())
            {
                foreach (columInfo curr in cInfos)
                {
                    string v = reader[curr.csvName];
                    //Debug.Log("index:" + index.ToString());
                    //row[index++] = v;

                    if (curr.valueType != BTabValueType.S && string.IsNullOrEmpty(v))
                    {
                        throw new Exception(string.Format("第{0}行不能为空 列:{1} 表:{2}", tab.GetRowCount() + 1, curr.csvName, outpath));
                    }

                    try
                    {
                        switch (curr.valueType)
                        {
                            case BTabValueType.I16:
                                short.Parse(v);
                                break;
                            case BTabValueType.I32:
                                int.Parse(v);
                                break;
                            case BTabValueType.F:
                                float.Parse(v);
                                break;
                        };
                    }
                    catch (Exception)
                    {
                        throw new Exception(string.Format("第{0}行格式有误 列:{1} 表:{2}", tab.GetRowCount() + 1, curr.csvName, outpath));
                    }

                    row.Add(v);
                }
                tab.AddRow(row);
                row.Clear();
            }

            //序列化
            {
                byte[] buffer = tab.Serialization();
                using (FileStream fs = new FileStream(outpath, FileMode.Create))
                {
                    //开始写入  
                    fs.Write(buffer, 0, buffer.Length);
                    //清空缓冲区、关闭流  
                    fs.Flush();
                    fs.Close();
                }
            }


        }
    }


    static void conversionCs(string csout, string name, string MainKey, columInfo[] cInfos)
    {
        string str = asset.text;
        str = str.Replace("<1>", name);
        string str1 = "";
        string str2 = "";
        foreach (columInfo curr in cInfos)
        {
            try
            {
                string trueName = curr.bsvName;
                switch (curr.valueType)
                {
                    case BTabValueType.I16:
                        {
                            str1 += string.Format("\r\n\t\t\t\t\tcase \"{0}\": dif.{1} = (short)(double)o22; break;", trueName, trueName);
                            str2 += string.Format("\r\n\tpublic short {0};", trueName);
                        }
                        break;
                    case BTabValueType.I32:
                        {
                            str1 += string.Format("\r\n\t\t\t\t\tcase \"{0}\": dif.{1} = (int)(double)o22; break;", trueName, trueName);
                            str2 += string.Format("\r\n\tpublic int {0};", trueName);
                        }
                        break;
                    case BTabValueType.F:
                        {
                            str1 += string.Format("\r\n\t\t\t\t\tcase \"{0}\": dif.{1} = (float)(double)o22; break;", trueName, trueName);
                            str2 += string.Format("\r\n\tpublic float {0};", trueName);
                        }
                        break;
                    case BTabValueType.S:
                        {
                            str1 += string.Format("\r\n\t\t\t\t\tcase \"{0}\": dif.{1} = (string)o22; break;", trueName, trueName);
                            str2 += string.Format("\r\n\tpublic string {0};", trueName);
                        }
                        break;
                }
            }
            catch (Exception)
            {
                //throw new Exception(string.Format("第{0}行格式有误 列:{1} 表:{2}", tab.GetRowCount() + 1, curr.csvName, name));
            }
        }
        str = str.Replace("<2>", str1);
        str = str.Replace("<3>", str2);
        str = str.Replace("<4>", MainKey);
        CreateFile(csout, str);
    }
    /**
    * path：文件创建目录
    * name：文件的名称
    * info：写入的内容
    */
    static void CreateFile(string csout, string info)
    {
        FileInfo t = new FileInfo(csout);
        if (t.Exists)
        {
            File.Delete(csout);
        }
        //文件流信息
        StreamWriter sw;
        sw = t.CreateText();
        //以行的形式写入信息
        sw.WriteLine(info);
        //关闭流
        sw.Close();
        //销毁流
        sw.Dispose();
    }

    struct columInfo
    {
        public string csvName;
        public string bsvName;
        public int csvIdx;
        public int bsvIdx;
        public BTabValueType valueType;
    }

    static void FindFiles(DirectoryInfo dir, String[] filterEXNames, List<FileInfo> out_Files)
    {
        //找到该目录下的文件 
        FileInfo[] fi = dir.GetFiles();
        foreach (FileInfo f in fi)
        {
            bool isFind = false;
            String exName = f.Extension.ToLower();
            foreach (String cmpEXName in filterEXNames)
            {
                if (exName == cmpEXName)
                {
                    isFind = true; break;
                }
            }
            if (!isFind) continue;//扩展名不匹配

            out_Files.Add(f);//加入到返回队列
        }


        DirectoryInfo[] subDir = dir.GetDirectories();
        foreach (DirectoryInfo d in subDir)
        {
            FindFiles(d, filterEXNames, out_Files);//递归遍历子目录
        }
    }

}
