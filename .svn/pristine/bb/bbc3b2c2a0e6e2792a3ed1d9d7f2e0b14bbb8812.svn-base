using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;

public class AstarFight : MonoBehaviour
{
    
    private GameObject main;

    /// <summary>
    /// 寻路X轴宽度
    /// </summary>
    public int DiameterX = 1;

    /// <summary>
    /// 寻路Y轴宽度
    /// </summary>
    public int DiameterY = 1;

    /// <summary>
    /// 随机
    /// </summary>
    //public int RandomRate = 40;

    /// <summary>
    /// 地图宽度
    /// </summary>
    public int MapWidth = 50;

    /// <summary>
    /// 地图高度
    /// </summary>
    public int MapHeight = 50;

    /// <summary>
    /// 单位宽度
    /// </summary>
    public int UnitWidth = 1;

    /// <summary>
    /// 其实x
    /// </summary>
    public int StartX = 0;

    /// <summary>
    /// 起始Y
    /// </summary>
    public int StartY = 0;

    /// <summary>
    /// 目标X
    /// </summary>
    public int TargetX = 0;

    /// <summary>
    /// 目标Y
    /// </summary>
    public int TargetY = 0;

    /// <summary>
    /// 是否提供跳点路径
    /// </summary>
    public bool IsJumpPoint = false;

    /// <summary>
    /// 地图加载
    /// </summary>
    public LoadMap LoadMap;

    /// <summary>
    /// 路径点对象
    /// </summary>
    public GameObject PathPoint;

    /// <summary>
    /// 路径点父级
    /// </summary>
    public GameObject PathPointFather;

    /// <summary>
    /// 集群引用
    /// </summary>
    public SchoolManager SchoolManager;


    private int maxX;

    private List<int> tempList = new List<int>();
    private List<int> tempList2 = new List<int>();
    //private int[] tempArray = { -1, -1,/**/-1, 0,/**/-1, 1,/**/ 0, 1, /**/1, 1, /**/1, 0,/**/ 1, -1, /**/0, -1 };

    /// <summary>
    /// 创建集群个数
    /// </summary>
    public int ItemCount = 1;

    public GameObject schoolItem;

    private int[][] mapInfoData;
    private int[][] tempList3 = new int[5][];
    private int[] zhenxingMaxX = new int[5];
    //public float maxPointX;
    private int tempInt = 0;
    void Start()
    {
        // 初始化
        Init();
    }

    /// <summary>
    /// 初始化战斗场景
    /// </summary>
    public void Init()
    {
        // TODO 文件应该从配置文件中读取
        var mapInfoPath = Application.dataPath + Path.AltDirectorySeparatorChar + "mapinfo";
        var mapInfoStr = Utils.LoadFileInfo(mapInfoPath);
        mapInfoData = DeCodeInfo(mapInfoStr);

        MapWidth = mapInfoData[0].Length;
        MapHeight = mapInfoData.Length;
        if (TargetX >= MapWidth || TargetX < 0)
        {
            TargetX = MapWidth - 1;
        }
        if (TargetY >= MapHeight || TargetY < 0)
        {
            TargetY = MapHeight - 1;
        }

        var fixtureList = LoadMap.Init(mapInfoData, UnitWidth);
        // 初始化集群管理
        var loadMapPos = LoadMap.GetLeftBottom();
        SchoolManager.Init(loadMapPos.x, loadMapPos.z, MapWidth, MapHeight, UnitWidth, mapInfoData);

        // 将障碍物加入列表
        foreach (var fixture in fixtureList)
        {
            var fixtureBehaviour = fixture.AddComponent<FixtureBehaviour>();
            fixtureBehaviour.Diameter *= UnitWidth;
            SchoolManager.Add(fixtureBehaviour);
        }
    }


    //public Vector3 isZhangAi(Vector3 mp)
    //{
    //    int[] a = Utils.PositionToNum(LoadMap.MapPlane.transform.position, mp, UnitWidth, MapWidth, MapHeight);
    //    if (a[0] > -1 && a[1] > -1 && a[0] < MapWidth && a[1] < MapHeight && mapInfoData[a[1]][a[0]] == 1)
    //    {
    //        Vector3 zhangAiP = Utils.NumToPosition(LoadMap.transform.position, new Vector2(a[0], a[1]), UnitWidth,
    //            MapWidth, MapHeight);
    //        float[] span = new float[4];
    //        float offsetX = zhangAiP.x - mp.x;
    //        float offsetZ = zhangAiP.z - mp.z;
    //        span[0] = UnitWidth / 2f + offsetZ;
    //        span[1] = UnitWidth / 2f - offsetZ;
    //        span[2] = UnitWidth / 2f - offsetX;
    //        span[3] = UnitWidth / 2f + offsetX;
    //        for (int i = 0; i < 4; i++)
    //        {
    //            if (span[i] < 0)
    //            {
    //                span[i] = 0;
    //            }
    //        }
    //        int tempInt;
    //        tempInt = 0;
    //        while (a[0] > -1 && ++a[1] > -1 && a[0] < MapWidth && a[1] < MapHeight && mapInfoData[a[1]][a[0]] == 1)
    //        {
    //            tempInt++;
    //        }
    //        a[1] -= (1 + tempInt);
    //        span[0] += tempInt * UnitWidth;
    //        tempInt = 0;
    //        while (a[0] > -1 && --a[1] > -1 && a[0] < MapWidth && a[1] < MapHeight && mapInfoData[a[1]][a[0]] == 1)
    //        {
    //            tempInt++;
    //        }
    //        a[1] += (1 + tempInt);
    //        span[1] += tempInt * UnitWidth;
    //        tempInt = 0;
    //        while (--a[0] > -1 && a[1] > -1 && a[0] < MapWidth && a[1] < MapHeight && mapInfoData[a[1]][a[0]] == 1)
    //        {
    //            tempInt++;
    //        }
    //        a[0] += (1 + tempInt);
    //        span[2] += tempInt * UnitWidth;
    //        tempInt = 0;
    //        while (++a[0] > -1 && a[1] > -1 && a[0] < MapWidth && a[1] < MapHeight && mapInfoData[a[1]][a[0]] == 1)
    //        {
    //            tempInt++;
    //        }
    //        a[0] -= (1 + tempInt);
    //        span[3] += tempInt * UnitWidth;

    //        for (int i = 0; i < 4; i++)
    //        {
    //            if (span[i] < 0)
    //            {
    //                span[i] = 0;
    //            }
    //        }
    //        float min = 999999;
    //        int tempInt2 = 0;
    //        for (int i = 0; i < 4; i++)
    //        {
    //            if (span[i] < min)
    //            {
    //                if (i == 3 && (mp.x + span[i]) > maxPointX)
    //                {
    //                    continue;
    //                }
    //                tempInt2 = i;
    //                min = span[tempInt2];
    //            }
    //        }

    //        switch (tempInt2)
    //        {
    //            case 0: return new Vector3(mp.x, mp.y, mp.z + min);
    //            case 1: return new Vector3(mp.x, mp.y, mp.z - min);
    //            case 2: return new Vector3(mp.x - min, mp.y, mp.z);
    //            case 3: return new Vector3(mp.x + min, mp.y, mp.z);
    //        }

    //    }
    //    return new Vector3(-9999, 0, 0);
    //}

    public Vector3 isZhangAi(Vector3 mp, int index)
    {
        int[] a = new int[2];
        int spani = 1;
        int tempMax;
        if (index == 4)
        {
            a[0] = (int)mp.x;
            a[1] = (int)mp.z;
            tempMax = 99999;
        }
        else
        {
            a = Utils.PositionToNum(LoadMap.MapPlane.transform.position, mp, UnitWidth, MapWidth, MapHeight);
            tempMax = maxX - zhenxingMaxX[index];
        }
        Vector3 tempP = Utils.NumToPosition(LoadMap.transform.position, new Vector2(a[0], a[1]), UnitWidth,
        MapWidth, MapHeight);
        //触摸点在格子中点的什么位置
        float[] aC = { (tempP.x - mp.x) / UnitWidth, (tempP.z - mp.z) / UnitWidth };

        tempList2.Clear();
        while (true)
        {
            tempList.Clear();
            if (spani == 1)
            {
                tempList.Add(0);
                tempList.Add(0);
            }
            int a1 = -spani;
            int b1 = -spani;
            int a2 = spani;
            int b2 = spani;
            for (int i = 1; i < 2 * spani + 1; i++)
            {
                tempList.Add(a1);
                tempList.Add(b1 + i);
                tempList.Add(a1 + i);
                tempList.Add(b1);
                tempList.Add(a2);
                tempList.Add(b2 - i);
                tempList.Add(a2 - i);
                tempList.Add(b2);
            }
            int templ = tempList.Count;
            tempList[templ - 4] = a1;
            tempList[templ - 3] = b1;
            tempList[templ - 2] = a2;
            tempList[templ - 1] = b2;
            spani++;

            for (int i = 0; i < tempList.Count; i += 2)
            {
                if (testPoint(a[0] + tempList[i], a[1] + tempList[i + 1], index) && (a[0] + tempList[i]) < tempMax)
                {
                    tempList2.Add(tempList[i]);
                    tempList2.Add(tempList[i + 1]);
                }
            }

            if (tempList2.Count > 0)
            {
                float min = 9999;
                float tempFloat;
                int tempInt2 = 0;
                for (int i = 0; i < tempList2.Count; i += 2)
                {
                    tempFloat = (float)(Math.Pow(aC[0] - tempList2[i], 2) + Math.Pow(aC[1] - tempList2[i + 1], 2));
                    if (tempFloat < min)
                    {
                        min = tempFloat;
                        tempInt2 = i;
                    }
                }
                return Utils.NumToPosition(LoadMap.transform.position, new Vector2(a[0] + tempList2[tempInt2], a[1] + tempList2[tempInt2 + 1]), UnitWidth, MapWidth, MapHeight);
            }
        }
    }

    public void setMaxX(float X)
    {
        maxX = (int)((X - LoadMap.MapPlane.transform.position.x + MapWidth * UnitWidth / 2) / UnitWidth);
    }
    public void setTempList3(int[] a, int index)
    {
        tempList3[index] = a;
        int sad = 1;
    }
    public void setZhenxingMaxX(int a, int index)
    {
        zhenxingMaxX[index] = a;

    }
    public Vector3 getNum(Vector3 p)
    {
        int[] a = Utils.PositionToNum(LoadMap.MapPlane.transform.position, p, UnitWidth, MapWidth, MapHeight);
        return new Vector3(a[0], 0, a[1]);

    }
    public void toXunLu(bool isEnemy, int groupIndex)
    {

        int[] a = Utils.PositionToNum(LoadMap.MapPlane.transform.position, schoolItem.transform.position, UnitWidth, MapWidth, MapHeight);
        IList<Node> path;
        if (!isEnemy)
        {
            path = AStarPathFinding.SearchRoad(mapInfoData, a[0], a[1], TargetX, a[1], DiameterX, DiameterY,
                IsJumpPoint);
        }
        else
        {
            path = AStarPathFinding.SearchRoad(mapInfoData, a[0], a[1], 1, a[1], DiameterX, DiameterY,
                IsJumpPoint);
        }


        // 清除所有组
        SchoolBehaviour school = schoolItem.AddComponent<SchoolBehaviour>();
        //school.GroupId = tempInt++;
        //TODODO
        school.GroupId = groupIndex;
        school.PhysicsInfo.MaxSpeed = 30;
        school.RotateSpeed = 1;
        school.RotateWeight = 1;
        school.Diameter = 1 * UnitWidth;

        school.transform.localPosition = new Vector3((tempInt % 3) * 2, 1, tempInt / 3 * 2) + Utils.NumToPosition(LoadMap.transform.position, new Vector2(a[0], a[1]), UnitWidth, MapWidth, MapHeight);

        school.Group.Target = Utils.NumToPosition(LoadMap.MapPlane.transform.position, new Vector2(path[path.Count - 1].X, path[path.Count - 1].Y), UnitWidth, MapWidth, MapHeight);
        this.SchoolManager.Add(school);

        Action<SchoolGroup> lambdaComplete = (thisGroup) =>
        {
            //Debug.Log("GroupComplete:" + thisGroup.Target);
            // 数据本地化
            // 数据结束
            if (path.Count == 0)
            {
                return;
            }
            path.RemoveAt(path.Count - 1);
            if (path.Count == 0)
            {
                return;
            }
            var node = path[path.Count - 1];
            thisGroup.Target = Utils.NumToPosition(LoadMap.MapPlane.transform.position, new Vector2(node.X, node.Y), UnitWidth, MapWidth, MapHeight);
        };
        school.Group.ProportionOfComplete = 1;
        school.Group.Complete = lambdaComplete;
    }
    
    private bool testPoint(int a0, int a1, int index)
    {
        int an = tempList3[index].Length;
        int x, y;
        for (int i = 0; i < an; i += 2)
        {
            x = a0 + tempList3[index][i];
            y = a1 + tempList3[index][i + 1];
            if (x > -1 && y > -1 && x < MapWidth && y < MapHeight && mapInfoData[y][x] == 1)
            {
                return false;
            }
        }
        return true;
    }

    /// <summary>
    /// TODO 解码地图数据
    /// </summary>
    /// <param name="mapInfoJson">地图数据json</param>
    /// <returns>地图数据数组</returns>
    private int[][] DeCodeInfo(string mapInfoJson)
    {
        if (string.IsNullOrEmpty(mapInfoJson))
        {
            return null;
        }
        //var mapData = new List<List<int>>();
        // 读出数据
        var mapLines = mapInfoJson.Split('\n');

        int[][] mapInfo = new int[mapLines.Length - 1][];
        for (var row = 0; row < mapLines.Length; row++)
        {
            var line = mapLines[row];
            if (string.IsNullOrEmpty(line))
            {
                continue;
            }
            var cells = line.Split(',');
            // Debug.Log(line);
            mapInfo[row] = new int[cells.Length];
            for (int col = 0; col < cells.Length; col++)
            {
                if (string.IsNullOrEmpty(cells[col].Trim()))
                {
                    continue;
                }
                //Debug.Log(cells[col]);
                mapInfo[row][col] = int.Parse(cells[col]);
            }
        }

        return mapInfo;
    }

}