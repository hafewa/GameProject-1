local class = require("common/middleclass")
local ui_fight = class("ui_fight", wnd_base)

--读取士兵配置表
-- require "framework.luacsv"
sdata_soldier_data = luacsv.new(require("pk_tabs/soldier_data"))

function ui_fight.show_me()
    local sd = ui_session_data(ui_session_type.FIXED, ui_session_id.UI_fight)
    m_ui_manager:show_session(ui_fight(sd))
end

function ui_fight:initialize(session_data)
    ui_session.initialize(self, session_data)
    self.session_id = ui_session_id.UI_shopScene
end


function ui_fight:on_post_load()
    math.newrandomseed()
    local time_txt = self.transform:Find("Win/time_bg/txt"):GetComponent("UILabel")
    local t = TimeTicker()
    t:Start(5 * 60)
    t.OnTick = function(go)
        local tempInt = math.ceil(t.OverTime)
        time_txt.text = string.format("%02d", math.modf(tempInt / 60)) .. ":" .. string.format("%02d", tempInt % 60)
    end
    
    t.OnEnd = function(go)
        time_txt.text = "00:00"
    end
    
    local myBloodBar = self.transform:Find("Win/defence_widget1/hp_fg"):GetComponent("UISprite")
    --    myBloodBar.fillAmount = 0.5
    localpaiStr = "1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,19,19,1,2,3,4,5,6,7,8,1,10,10,10,10,10"
    -- localpaiStr = "1,2,3,4,5,6"
    --剩余牌库
    self.paiKutb = string.splitToInt(localpaiStr, ",")
    --打乱牌库
    for i = #self.paiKutb, 1, -1 do
        local index = math.random(#self.paiKutb)
        local tempNum = self.paiKutb[i]
        self.paiKutb[i] = self.paiKutb[index]
        self.paiKutb[index] = tempNum
    end
    --当前手牌库
    self.nowHandpaiKutb = {}
    --取前4张为手牌库
    for i = 1, 4 do
        self.nowHandpaiKutb[i] = self.paiKutb[1]
        table.remove(self.paiKutb, 1)
    end
    
    --牌库UI
    self.paiKuBg = self.transform:Find("Win/paiKuBg")
    --长按牌库显示
    local shengyu_bgDelay1Ct
    UIEventListener.Get(self.transform:Find("Win/shengyu_bg").gameObject).onPress = function(go, args)
        if args then -- 开启协程
            shengyu_bgDelay1Ct = coroutine.start(function()
                coroutine.wait(0.5)
                --设置牌库信息
                self:getPaiKuPerCardNum();
                self.paiKuBg.gameObject:SetActive(true)
            end)
        else -- 停止协程
            self.paiKuBg.gameObject:SetActive(false)
            coroutine.stop(shengyu_bgDelay1Ct)
        end
    end
    --剩余兵力值
    self.sumLastBingLi = 0
    for i = 2, #self.paiKutb do
        self.sumLastBingLi = self.sumLastBingLi + sdata_soldier_data:GetV(sdata_soldier_data.I_TrainCost, self.paiKutb[i])
    end
    --剩余兵力Label
    self.allBingLiLabel = self.transform:Find("Win/shengyu_bg/allBingLi"):GetComponent(typeof(UILabel))
    self.allBingLiLabel.text = self.sumLastBingLi
    -- UI卡牌框数
    self.uiCardNum = 4
    -- UI技能框数
    self.uiSkillNum = 3
    -- 当前3d相机
    self.nowWorldCamera = GameObject.Find("/PTZCamera/SceneryCamera"):GetComponent(typeof(UnityEngine.Camera))
    -- 当前UI相机
    self.nowUICamera = GameObject.Find("/UIRoot/Camera_UI"):GetComponent(typeof(UnityEngine.Camera))
    -- DragDropRoot
    self.DragDropRoot = GameObject.Find("/UIRoot/DragDropRoot").transform
    -- 装载ui卡牌的panel
    self.currentCards_bg = self.transform:Find("Win/currentCards_bg")
    -- 下一张卡牌的UISprite
    self.nextCardSpr = self.transform:Find("Win/currentCards_bg/nextCard"):GetComponent(typeof(UISprite))
    self.nextCardSpr.spriteName = sdata_soldier_data:GetV(sdata_soldier_data.I_CardImageID, self.paiKutb[1])
    -- 下一张卡牌的UILabel
    self.nextCardLabel = self.transform:Find("Win/currentCards_bg/nextCard/costLabel"):GetComponent(typeof(UILabel))
    self.nextCardLabel.text = sdata_soldier_data:GetV(sdata_soldier_data.I_TrainCost, self.paiKutb[1])
    --费barUISprite
    local feiBgTf = self.transform:Find("Win/currentCards_bg/feiBg")
    self.feiBarSpr = self.transform:Find("Win/currentCards_bg/feiBg/feiBar"):GetComponent(typeof(UISprite))
    --总费Label
    self.allFeiLabel = self.transform:Find("Win/currentCards_bg/feiBg/allFeiLabel"):GetComponent(typeof(UILabel))
    --当前费Label
    self.nowFeiLabel = self.transform:Find("Win/currentCards_bg/feiBg/nowFeiLabel"):GetComponent(typeof(UILabel))
    --回收费Label
    self.huiShouLabel = self.transform:Find("Win/currentCards_bg/feiBg/addFeiLabel"):GetComponent(typeof(UILabel))
    --总费
    self.allFei = 1000; self.allFeiLabel.text = self.allFei .. ""
    --当前费
    self.nowFei = 1000; self.nowFeiLabel.text = self.nowFei .. ""
    -- 拖动中的卡牌table
    self.onPressMyCardtb = {}
    -- 下方卡牌缩放间距
    self.onPressMyCardSpantb = {}
    -- 拖动中的卡牌模型table
    self.onPressArmytb = {}
    -- UI卡牌table
    self.nowMyCardtb = {}
    -- UI卡牌CDtable
    self.nowMyCardCDtbUISpritetb = {}
    -- UI技能table
    self.uiSkilltb = {}
    -- UI卡牌原始位置
    self.myCardConstPostb = {}
    -- 下方下牌边框
    self.downCardY = -250
    -- 上方下牌边框
    self.upCardY = 190
    -- 卡牌缩放间距
    self.cardScaleSpan = 88
    -- UI卡牌原始位置
    self.myCardConstPostb = {}
    -- 相机移动BoxScrollObject
    self.BoxScrollObject = GameObject.Find("/PTZCamera"):GetComponent(typeof(BoxScrollObject))
    -- PTZCamera相机
    self.PTZCameraTf = GameObject.Find("/PTZCamera").transform
    -- 卡牌信息tf
    self.cardInfoBg = self.transform:Find("Win/cardInfoBg")
    --EasyTouch 委托
    self.easyTouchHandler = {}
    --费Bounds
    local feiUIWidget = feiBgTf:GetComponent(typeof(UIWidget))
    feiBgTf.parent = self.DragDropRoot
    self.feiBounds = Bounds(Vector3(feiBgTf.localPosition.x, feiBgTf.localPosition.y, 0), Vector3(feiUIWidget.width, feiUIWidget.height, 0))
    feiBgTf.parent = self.currentCards_bg
    -- UIRoot的locationScale
    self.urlc = GameObject.Find("/UIRoot").transform.localScale.x
    --不可下兵区域
    coroutine.start(function()--开场还没加载到所以用协程
        while self.canotRect == nil do
            coroutine.wait(0.1)
            self.canotRect = GameObject.Find("/canotRectGo")
            if self.canotRect then
                self.maxPointX = self.canotRect.transform.position.x
                --不可下兵区域tf
                self.canotRect = self.canotRect.transform:Find("canotRect")
            end
        end
    end)
    -----------------------------------卡牌UI获取
    for var = 1, self.uiCardNum do
        local tf = self.transform:Find("Win/currentCards_bg/currentCard" .. var)
        self.nowMyCardtb[var] = tf
        self.myCardConstPostb[var] = tf.position
        --添加拖拽脚本
        tf.gameObject:AddComponent(typeof(UIDragObjectEX))
        local go = tf.gameObject
        self.nowMyCardCDtbUISpritetb[var] = tf:Find("CDBar"):GetComponent("UISprite")
        tf:GetComponent(typeof(UISprite)).spriteName = sdata_soldier_data:GetV(sdata_soldier_data.I_CardImageID, self.nowHandpaiKutb[var])
        tf:Find("costLabel"):GetComponent(typeof(UILabel)).text = sdata_soldier_data:GetV(sdata_soldier_data.I_TrainCost, self.nowHandpaiKutb[var])
        local shengyu_bgDelay1Ct
        UIEventListener.Get(tf.gameObject).onDragStart = function(go)
                --拖动事件
                coroutine.stop(shengyu_bgDelay1Ct)
                self.canotRect.gameObject:SetActive(true)
                self.cardInfoBg.gameObject:SetActive(false)
        end
        
        UIEventListener.Get(tf.gameObject).onPress = function(go, args)
            if args then
                print("点击事件")
                -- 点击事件
                --长按显示卡牌信息
                shengyu_bgDelay1Ct = coroutine.start(function()
                    coroutine.wait(0.5)
                    self.cardInfoBg.gameObject:SetActive(true)
                    self.cardInfoBg.localPosition = tf.localPosition + Vector3(0, 100, 0)
                end)
                
                -- 把其他前置状态的牌归位
                for var2 = 1, self.uiCardNum do
                    -- 如果处于前置状态
                    if self.nowMyCardtb[var2].localPosition.y > 10 then
                        -- 如果卡牌没有点击中
                        if table.indexof(self.onPressMyCardtb, self.nowMyCardtb[var2]) == false then
                            -- 如果不是自己
                            if var ~= var2 then
                                TweenPosition.Begin(self.nowMyCardtb[var2].gameObject, Vector3.Distance(self.nowMyCardtb[var2].position, self.myCardConstPostb[var2]) / 2, self.myCardConstPostb[var2], true)
                            end
                        end
                    end
                end
                
                --计算下方卡牌缩放间距
                local tempInt = #self.onPressMyCardtb + 1
                if tf.localPosition.y < 20 then
                    self.onPressMyCardSpantb[tempInt] = self.cardScaleSpan
                else
                    self.onPressMyCardSpantb[tempInt] = self.cardScaleSpan - 25
                end
                
                self.onPressMyCardtb[tempInt] = tf
                tf.parent = self.DragDropRoot
                self.DragDropRoot.gameObject:SetActive(false)
                self.DragDropRoot.gameObject:SetActive(true)
                
                --生成模型
                local ct = self:getModel(sdata_soldier_data:GetV(sdata_soldier_data.I_ArmyID, self.nowHandpaiKutb[var]))
                ct.localScale = Vector3.zero
                ct.gameObject:SetActive(true)
                self.onPressArmytb[tempInt] = ct
            else --松开卡牌
                self.cardInfoBg.gameObject:SetActive(false)
                coroutine.stop(shengyu_bgDelay1Ct)
                local tempY = self.nowUICamera:ScreenToWorldPoint(self:getTouchPoint(var - 1)).y / self.urlc
                if self.nowFei >= sdata_soldier_data:GetV(sdata_soldier_data.I_TrainCost, self.nowHandpaiKutb[var]) and (tempY > self.downCardY) and (tempY < self.upCardY) then --拖到屏幕中
                    local ray
                    if Input.touchCount == 0 then -- 编辑器平台和手机平台不同的触摸
                        ray = self.nowWorldCamera:ScreenPointToRay(Input.mousePosition)
                    else
                        ray = self.nowWorldCamera:ScreenPointToRay(Vector3(Input.GetTouch(var - 1).position.x, Input.GetTouch(var - 1).position.y, 0))
                    end
                    
                    local isC, hit = UnityEngine.Physics.Raycast(ray, hit, 1000, 256)--256 == bit.lshift(1, 8) == 1<<8
                    if isC and hit.point.x < self.maxPointX then --判断是否在不可下兵区域
                        self:doEvent(tf, var, 3)
                    else --拖回下方
                        self:doEvent(tf, var, 0)
                    end
                else
                    local cardBounds = Bounds(tf.localPosition, Vector3(self.nowMyCardSizetb.x, self.nowMyCardSizetb.y, 0) * tf.localScale.x)
                    if self.feiBounds:Intersects(cardBounds) then --回收卡
                        self:doEvent(tf, var, 1)
                    else --拖回下方
                        self:doEvent(tf, var, 0)
                    end
                end
            end
        end
    end
    
    
    
    local cardWidget = self.nowMyCardtb[1]:GetComponent(typeof(UIWidget))
    -- UI卡牌Size
    self.nowMyCardSizetb = Vector2(cardWidget.width, cardWidget.height) / 8
    -----------------------------------技能UI获取
    for var = 1, self.uiSkillNum do
        local tf = self.transform:Find("Win/currentCards_bg/skill" .. var)
        self.uiSkilltb[var] = tf
        local go = tf.gameObject
        UIEventListener.Get(tf.gameObject).onPress = function(go, args)
            if args then
                end
        end
    end
    -----------------------------------单击屏幕出牌
    self.easyTouchHandler[1] = function()
        self.lastMousePosition = Input.mousePosition
    end
    EasyTouch.On_TouchStart = EasyTouch.On_TouchStart + self.easyTouchHandler[1]
    self.easyTouchHandler[2] = function()
        if self.lastMousePosition then --可能一瞬间会有1次以上的回调，保证只走一次逻辑
            local tempY = self.nowUICamera:ScreenToWorldPoint(Input.mousePosition).y / self.urlc
            if (tempY > self.downCardY) and (tempY < self.upCardY) then
                for var = 1, 4 do
                    if self.nowMyCardtb[var].localPosition.y > 20 and self.nowFei >= sdata_soldier_data:GetV(sdata_soldier_data.I_TrainCost, self.nowHandpaiKutb[var]) and Vector3.Distance(self.lastMousePosition, Input.mousePosition) < 20 then
                        if self:doEvent(self.nowMyCardtb[var], var, 4) then
                            self.lastMousePosition = nil
                        end
                        break
                    end
                end
            end
        end
    end
    EasyTouch.On_TouchUp = EasyTouch.On_TouchUp + self.easyTouchHandler[2]
    
    -----------------------------------长按头像显示用户信息
    local delay1Ct = {}
    local userInfoBg = self.transform:Find("Win/userInfoBg")
    for var = 1, 2 do
        UIEventListener.Get(self.transform:Find("Win/defence_widget" .. var .. "/bg2").gameObject).onPress = function(go, args)
            if args then -- 开启协程
                delay1Ct[var] = coroutine.start(function()
                    coroutine.wait(0.5)
                    userInfoBg.localPosition = Vector3(-107 + (var - 1) * 240.8, 355, 0)
                    userInfoBg.gameObject:SetActive(true)
                end)
            else -- 停止协程
                userInfoBg.gameObject:SetActive(false)
                coroutine.stop(delay1Ct[var])
            end
        end
    end
    
    --小地图显隐标志
    local isMapOut = true
    --小地图隐藏panel
    local mapPanel = self.transform:Find("Win/mapPanel")
    --小地图
    local map_bg = self.transform:Find("Win/map_bg")
    --小地图显隐按钮 UISprite
    local btn_backMapSpr = self.transform:Find("Win/btn_backMap"):GetComponent(typeof(UISprite))
    
    local tp
    UIEventListener.Get(self.transform:Find("Win/btn_backMap").gameObject).onPress = function(go, args)
        if args == false then --打开关闭小地图
            if isMapOut then
                map_bg.parent = mapPanel
                mapPanel.gameObject:SetActive(true)
                btn_backMapSpr.flip = UIBasicSprite.Flip.Nothing
                tp = TweenPosition.Begin(map_bg.gameObject, map_bg.position:Distance(Vector3(-0.75, 0, 0)) / 5, Vector3(-0.75, 0, 0), true)
            else
                map_bg.parent = self.transform:Find("Win")
                btn_backMapSpr.flip = UIBasicSprite.Flip.Horizontally
                -- TweenPosition.Begin(map_bg.gameObject, map_bg.position:Distance(Vector3.zero) / 5, Vector3.zero, true)
                tp:PlayReverse()
            end
            isMapOut = not isMapOut
        end
    end
end


--获取模型
function ui_fight:getModel(id)
    local mod
    -- if id == 1 then
    --     mod = DP_FightPrefabManage.InstantiateAvatar(AvatarCM.Infantry_R, false, 0, "daobing", "daobing", true).transform
    -- elseif id == 2 then
    --     mod = DP_FightPrefabManage.InstantiateAvatar(AvatarCM.Infantry_R, false, 0, "gongjianbing", "gongjianbing", true).transform
    -- elseif id == 3 then
    --     mod = DP_FightPrefabManage.InstantiateAvatar(AvatarCM.Infantry_R, false, 0, "qingzhoujun", "qingzhoujun", true).transform
    -- elseif id == 4 then
    --     mod = DP_FightPrefabManage.InstantiateAvatar(AvatarCM.Infantry_R, false, 0, "changqiangbing", "changqiangbing", true).transform
    -- elseif id == 5 then
    -- mod = DP_FightPrefabManage.InstantiateAvatar(AvatarCM.CavalryHero_RH, false, 0, "sunluban", "sunluban", true).transform
    -- elseif id == 6 then
    --     mod = DP_FightPrefabManage.InstantiateAvatar(AvatarCM.CavalryHero_RH, false, 0, "zhangxingcai", "zhangxingcai", true).transform
    -- elseif id == 7 then
    --     mod = DP_FightPrefabManage.InstantiateAvatar(AvatarCM.CavalryHero_RH, false, 0, "zhenji1", "zhenji1", true).transform
    -- elseif id == 8 then
    --     mod = DP_FightPrefabManage.InstantiateAvatar(AvatarCM.CavalryHero_RH, false, 0, "lingtong", "lingtong", true).transform
    -- elseif id == 19 then
    --     mod = DP_FightPrefabManage.InstantiateAvatar(AvatarCM.Horse_H, false, 0, "ma1", "zhenji1", true).transform
    -- elseif id == 10 then
    --     mod = DP_FightPrefabManage.InstantiateAvatar(AvatarCM.Horse_H, false, 0, "ma5", "xiahoudun", true).transform
    -- end
    -- if id<6 then
    --     mod = DP_FightPrefabManage.InstantiateAvatar(AvatarCM.CavalryHero_RH, false, 0, "sunluban", "sunluban", true).transform
    -- else
    mod = DP_FightPrefabManage.InstantiateAvatar(AvatarCM.InfantryHero_R, false, 0, "usasoldier", "usasoldier", true).transform
    -- end
    
    
    mod:GetComponent(typeof(MFAModelRender)).speedScale = 0
    mod:GetComponent(typeof(UnityEngine.MeshRenderer)).material.shader = UnityEngine.Shader.Find("QK/Transparent Colored Gray")
    return mod
end

-- 编辑器平台和手机平台不同的触摸
function ui_fight:getTouchPoint(var)
    if Input.touchCount == 0 then
        return Input.mousePosition
    else
        return Input.GetTouch(var).position
    end
end

--算出每个元素各有几个
function ui_fight:getPaiKuPerCardNum()
    local lastPaiID = {}
    local lastPaiNum = {}
    local tempPaiKutb = {}
    table.merge(tempPaiKutb, self.paiKutb)
    table.remove(tempPaiKutb, 1)
    local tempInt1 = 1
    local tempInt2 = 1
    while #tempPaiKutb > 0 do
        local i = 2
        while i <= #tempPaiKutb do
            if tempPaiKutb[i] == tempPaiKutb[1] then
                tempInt2 = tempInt2 + 1
                table.remove(tempPaiKutb, i)
                i = i - 1
            end
            i = i + 1
        end
        
        lastPaiID[tempInt1] = tempPaiKutb[1]
        lastPaiNum[tempInt1] = tempInt2
        table.remove(tempPaiKutb, 1)
        tempInt2 = 1
        tempInt1 = tempInt1 + 1
    end
    
    local tempInt = #lastPaiID
    local pai
    if tempInt > 9 then
        tempInt = 8
        pai = self.paiKuBg.transform:Find("paikuCard" .. 9)
        pai:GetComponent(typeof(UISprite)).spriteName = "face_3"
        pai:Find("costLabel").gameObject:SetActive(false)
        local tempInt2 = 0
        for i = 9, #lastPaiID do
            tempInt2 = tempInt2 + lastPaiNum[i]
        end
        pai:Find("remainNumLabel"):GetComponent(typeof(UILabel)).text = "*" .. tempInt2
        pai.gameObject:SetActive(true)
    elseif tempInt == 9 then
        self.paiKuBg.transform:Find("paikuCard" .. 9):Find("costLabel").gameObject:SetActive(true)
    else
        for i = tempInt + 1, 9 do
            self.paiKuBg.transform:Find("paikuCard" .. i).gameObject:SetActive(false)
        end
    end
    for i = 1, tempInt do
        pai = self.paiKuBg.transform:Find("paikuCard" .. i)
        pai:GetComponent(typeof(UISprite)).spriteName = sdata_soldier_data:GetV(sdata_soldier_data.I_CardImageID, lastPaiID[i])
        pai:Find("costLabel"):GetComponent(typeof(UILabel)).text = sdata_soldier_data:GetV(sdata_soldier_data.I_TrainCost, lastPaiID[i])
        pai:Find("remainNumLabel"):GetComponent(typeof(UILabel)).text = "*" .. lastPaiNum[i]
        pai.gameObject:SetActive(true)
    end
end



--事件处理
function ui_fight:doEvent(tf, var, isXiaBing)
    if isXiaBing > 0 then -- 下兵或回收事件
        print("下兵或回收事件")
        if isXiaBing > 2 then -- 下兵
            if isXiaBing == 3 then --拖动下兵
                self:backCallback(tf)
            elseif isXiaBing == 4 then --点击下兵
                local ray = self.nowWorldCamera:ScreenPointToRay(Input.mousePosition)
                local isC, hit = UnityEngine.Physics.Raycast(ray, hit)
                if isC then
                    if hit.point.x > self.maxPointX then --判断是否在不可下兵区域
                        return false
                    end
                    --生成模型
                    local ct = self:getModel(sdata_soldier_data:GetV(sdata_soldier_data.I_ArmyID, self.nowHandpaiKutb[var]))
                    ct.gameObject:SetActive(true)
                    ct.gameObject:AddComponent(typeof(myTest));
                    ct.position = hit.point
                end
            end
            --消耗费
            self.nowFei = self.nowFei - sdata_soldier_data:GetV(sdata_soldier_data.I_TrainCost, self.nowHandpaiKutb[var])
            self.nowFeiLabel.text = self.nowFei .. ""
        else -- 回收卡
            print("回收卡")
            self.huiShouLabel.gameObject:SetActive(false)
            if isXiaBing == 1 then
                self:backCallback(tf, var)
            end
            if (self.nowFei < self.allFei) == false then --如果满费则什么也不做
                if isXiaBing == 1 then
                    -- 卡牌前置
                    tf.position = self.myCardConstPostb[var]
                    tf.localPosition = tf.localPosition + Vector3(0, 25, 0)
                end
                return false
            end
            self.nowFei = self.nowFei + sdata_soldier_data:GetV(sdata_soldier_data.I_TrainCost, self.nowHandpaiKutb[var])
        end
        
        tf.localPosition = Vector3(-566, 2.9, 0)
        tf.localScale = Vector3(0, 0, 1)
        
        
        --如果没有选中的卡牌就把不可下兵区域隐藏
        local tempInt = 0
        for var = 1, 4 do
            if self.nowMyCardtb[var].localPosition.y > 20 then
                tempInt = tempInt + 1
                break
            end
        end
        if tempInt == 0 then
            self.canotRect.gameObject:SetActive(false)
        end
        
        -- 延迟1秒从下一张卡牌位置飞到原位置
        local t = TimeTicker()
        t:Start(1)
        t.OnEnd = function(go)
            if #self.paiKutb > 0 then --牌库有牌
                TweenPosition.Begin(self.nowMyCardtb[var].gameObject, 0.2, self.myCardConstPostb[var], true)
                TweenScale.Begin(self.nowMyCardtb[var].gameObject, 0.2, Vector3.one)
                --设置补充手牌为下一张手牌信息
                tf:GetComponent(typeof(UISprite)).spriteName = self.nextCardSpr.spriteName
                tf:Find("costLabel"):GetComponent(typeof(UILabel)).text = self.nextCardLabel.text
                --牌库第一张补充到手牌中并移除
                self.nowHandpaiKutb[var] = self.paiKutb[1]
                table.remove(self.paiKutb, 1)
                if #self.paiKutb > 0 then --牌库有牌
                    --设置下一张手牌为牌库第一张
                    local costFei = sdata_soldier_data:GetV(sdata_soldier_data.I_TrainCost, self.paiKutb[1])
                    self.nextCardSpr.spriteName = sdata_soldier_data:GetV(sdata_soldier_data.I_CardImageID, self.paiKutb[1])
                    self.nextCardLabel.text = costFei
                    --剩余兵力减少
                    self.sumLastBingLi = self.sumLastBingLi - costFei
                    self.allBingLiLabel.text = self.sumLastBingLi
                else --牌库没有牌了
                    self.transform:Find("Win/currentCards_bg/nextCard").gameObject:SetActive(false)
                end
            end
        end
    else -- 返回事件
        print("返回事件")
        self:backCallback(tf, var)
        -- 卡牌前置
        tf.position = self.myCardConstPostb[var]
        tf.localPosition = tf.localPosition + Vector3(0, 25, 0)
        self.canotRect.gameObject:SetActive(true)
    end
    
    return true
end

function ui_fight:backCallback(tf, var)
    --父节点还原，临时table清空，模型销毁
    tf.parent = self.currentCards_bg
    self.currentCards_bg.gameObject:SetActive(false)
    self.currentCards_bg.gameObject:SetActive(true)
    local i = table.removebyvalue2(self.onPressMyCardtb, tf)
    if var then
        tf.localScale = Vector3.one
        Object.Destroy(table.remove(self.onPressArmytb, i).gameObject)
    else
        -- self.onPressArmytb[i]:Find("Quan"):GetComponent("MeshCollider").enabled = true
        self.onPressArmytb[i].gameObject:AddComponent(typeof(myTest));
        table.remove(self.onPressArmytb, i)
    end
end

function ui_fight:Update()
    local tempInt = #self.onPressMyCardtb
    if tempInt > 0 then
        local tempX = self.nowUICamera:ScreenToWorldPoint(self:getTouchPoint(0)).x / self.urlc
        if tempX < -550 then
            self.BoxScrollObject:MoveTo(self.PTZCameraTf.position - Vector3(10, 0, 0))
        elseif tempX > 550 then
            self.BoxScrollObject:MoveTo(self.PTZCameraTf.position + Vector3(10, 0, 0))
        end
    
    end
    local tempY
    for var = 1, tempInt do
        tempY = self.nowUICamera:ScreenToWorldPoint(self:getTouchPoint(var - 1)).y / self.urlc
        if tempY < self.downCardY then --卡牌在下方区域显示并缩放，模型隐藏
            tempY = (self.downCardY - tempY) / self.onPressMyCardSpantb[var]
            if tempY > 1 then
                self.onPressMyCardtb[var].localScale = Vector3.one
            else
                self.onPressMyCardtb[var].localScale = Vector3(tempY, tempY, 1)
            end
            self.onPressArmytb[var].localScale = Vector3.zero
            --卡牌滑动在费上显示回收价格
            local cardBounds = Bounds(self.onPressMyCardtb[var].localPosition, Vector3(self.nowMyCardSizetb.x, self.nowMyCardSizetb.y, 0) * self.onPressMyCardtb[var].localScale.x)
            if self.feiBounds:Intersects(cardBounds) then --回收卡
                local tempCost = sdata_soldier_data:GetV(sdata_soldier_data.I_TrainCost, self.nowHandpaiKutb[var]) * 0.5
                if (self.allFei - self.nowFei) < tempCost then
                    tempCost = self.allFei - self.nowFei
                end
                self.huiShouLabel.text = "+" .. tempCost
                self.huiShouLabel.gameObject:SetActive(true)
            else
                self.huiShouLabel.gameObject:SetActive(false)
            end
        elseif tempY > self.upCardY then --卡牌在上方区域显示并缩放，模型隐藏
            tempY = (tempY - self.upCardY) / self.cardScaleSpan
            if tempY > 1 then
                self.onPressMyCardtb[var].localScale = Vector3.one
            else
                self.onPressMyCardtb[var].localScale = Vector3(tempY, tempY, 1)
            end
            self.onPressArmytb[var].localScale = Vector3.zero
        else --卡牌在中间区域隐藏，模型显示
            self.onPressMyCardtb[var].localScale = Vector3(0, 0, 1)
            self.onPressArmytb[var].localScale = Vector3.one
        end
        
        -- 模型跟随鼠标位置移动
        local ray
        if Input.touchCount == 0 then -- 编辑器平台和手机平台不同的触摸
            ray = self.nowWorldCamera:ScreenPointToRay(Input.mousePosition)
        else
            ray = self.nowWorldCamera:ScreenPointToRay(Vector3(Input.GetTouch(var - 1).position.x, Input.GetTouch(var - 1).position.y, 0))
        end
        
        local isC, hit = UnityEngine.Physics.Raycast(ray, hit, 1000, 256)--256 == bit.lshift(1, 8) == 1<<8
        -- local isC, hit = UnityEngine.Physics.Raycast(ray, hit)
        if isC then
            self.onPressArmytb[var].position = hit.point
        end
    end
    
    --卡牌CD
    for var = 1, 4 do
        local tempInt = sdata_soldier_data:GetV(sdata_soldier_data.I_TrainCost, self.nowHandpaiKutb[var])
        if self.nowFei < tempInt then
            self.nowMyCardCDtbUISpritetb[var].fillAmount = 1 - self.nowFei / tempInt
        else
            self.nowMyCardCDtbUISpritetb[var].fillAmount = 0
        end
    
    end
    
    --费每秒增长
    self.nowFei = self.nowFei + 1
    if self.nowFei > self.allFei then
        self.nowFei = self.allFei
        self.feiBarSpr.fillAmount = 1
    else
        self.feiBarSpr.fillAmount = self.nowFei / self.allFei
    end
    self.nowFeiLabel.text = math.round(self.nowFei) .. ""


end

function ui_fight:reset_window(args)

end

--销毁时清除该类中easytouch回调
function ui_fight:on_pre_destroy()
    EasyTouch.On_TouchStart = EasyTouch.On_TouchStart - self.easyTouchHandler[1]
    EasyTouch.On_TouchUp = EasyTouch.On_TouchUp - self.easyTouchHandler[2]
end

local isFirstShow = true
ui_fight_in = nil --单例
function ui_fight:Start()
    self:Init(WND.fight_ui)
    ui_fight_in = self
end


function ui_fight:OnShowDone()
--显示主面板
end

function ui_fight:OnNewInstance()
    self.UI:AddComponent(typeof(LuaBehaviour)):Init(self)
    self:on_post_load()
end


function ui_fight:OnLostInstance()

end

function ui_fight:Show(duration)
    
    self:_Show(duration)
end

function ui_fight:Hide(duration)
    
    self:_Hide(duration)
end


return ui_fight
